/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "mapd_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>



int _kTDatumTypeValues[] = {
  TDatumType::SMALLINT,
  TDatumType::INT,
  TDatumType::BIGINT,
  TDatumType::FLOAT,
  TDatumType::DECIMAL,
  TDatumType::DOUBLE,
  TDatumType::STR,
  TDatumType::TIME,
  TDatumType::TIMESTAMP,
  TDatumType::DATE,
  TDatumType::BOOL,
  TDatumType::INTERVAL_DAY_TIME,
  TDatumType::INTERVAL_YEAR_MONTH,
  TDatumType::POINT,
  TDatumType::LINESTRING,
  TDatumType::POLYGON,
  TDatumType::MULTIPOLYGON,
  TDatumType::TINYINT,
  TDatumType::GEOMETRY,
  TDatumType::GEOGRAPHY
};
const char* _kTDatumTypeNames[] = {
  "SMALLINT",
  "INT",
  "BIGINT",
  "FLOAT",
  "DECIMAL",
  "DOUBLE",
  "STR",
  "TIME",
  "TIMESTAMP",
  "DATE",
  "BOOL",
  "INTERVAL_DAY_TIME",
  "INTERVAL_YEAR_MONTH",
  "POINT",
  "LINESTRING",
  "POLYGON",
  "MULTIPOLYGON",
  "TINYINT",
  "GEOMETRY",
  "GEOGRAPHY"
};
const std::map<int, const char*> _TDatumType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(20, _kTDatumTypeValues, _kTDatumTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TDatumType::type& val) {
  std::map<int, const char*>::const_iterator it = _TDatumType_VALUES_TO_NAMES.find(val);
  if (it != _TDatumType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTEncodingTypeValues[] = {
  TEncodingType::NONE,
  TEncodingType::FIXED,
  TEncodingType::RL,
  TEncodingType::DIFF,
  TEncodingType::DICT,
  TEncodingType::SPARSE,
  TEncodingType::GEOINT
};
const char* _kTEncodingTypeNames[] = {
  "NONE",
  "FIXED",
  "RL",
  "DIFF",
  "DICT",
  "SPARSE",
  "GEOINT"
};
const std::map<int, const char*> _TEncodingType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(7, _kTEncodingTypeValues, _kTEncodingTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TEncodingType::type& val) {
  std::map<int, const char*>::const_iterator it = _TEncodingType_VALUES_TO_NAMES.find(val);
  if (it != _TEncodingType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTExecuteModeValues[] = {
  TExecuteMode::HYBRID,
  TExecuteMode::GPU,
  TExecuteMode::CPU
};
const char* _kTExecuteModeNames[] = {
  "HYBRID",
  "GPU",
  "CPU"
};
const std::map<int, const char*> _TExecuteMode_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kTExecuteModeValues, _kTExecuteModeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TExecuteMode::type& val) {
  std::map<int, const char*>::const_iterator it = _TExecuteMode_VALUES_TO_NAMES.find(val);
  if (it != _TExecuteMode_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTDeviceTypeValues[] = {
  TDeviceType::CPU,
  TDeviceType::GPU
};
const char* _kTDeviceTypeNames[] = {
  "CPU",
  "GPU"
};
const std::map<int, const char*> _TDeviceType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kTDeviceTypeValues, _kTDeviceTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TDeviceType::type& val) {
  std::map<int, const char*>::const_iterator it = _TDeviceType_VALUES_TO_NAMES.find(val);
  if (it != _TDeviceType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTTableTypeValues[] = {
  TTableType::DELIMITED,
  TTableType::POLYGON
};
const char* _kTTableTypeNames[] = {
  "DELIMITED",
  "POLYGON"
};
const std::map<int, const char*> _TTableType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kTTableTypeValues, _kTTableTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TTableType::type& val) {
  std::map<int, const char*>::const_iterator it = _TTableType_VALUES_TO_NAMES.find(val);
  if (it != _TTableType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTMergeTypeValues[] = {
  TMergeType::UNION,
  TMergeType::REDUCE
};
const char* _kTMergeTypeNames[] = {
  "UNION",
  "REDUCE"
};
const std::map<int, const char*> _TMergeType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kTMergeTypeValues, _kTMergeTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TMergeType::type& val) {
  std::map<int, const char*>::const_iterator it = _TMergeType_VALUES_TO_NAMES.find(val);
  if (it != _TMergeType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTExpressionRangeTypeValues[] = {
  TExpressionRangeType::INVALID,
  TExpressionRangeType::INTEGER,
  TExpressionRangeType::FLOAT,
  TExpressionRangeType::DOUBLE
};
const char* _kTExpressionRangeTypeNames[] = {
  "INVALID",
  "INTEGER",
  "FLOAT",
  "DOUBLE"
};
const std::map<int, const char*> _TExpressionRangeType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kTExpressionRangeTypeValues, _kTExpressionRangeTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TExpressionRangeType::type& val) {
  std::map<int, const char*>::const_iterator it = _TExpressionRangeType_VALUES_TO_NAMES.find(val);
  if (it != _TExpressionRangeType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTDBObjectTypeValues[] = {
  TDBObjectType::AbstractDBObjectType,
  TDBObjectType::DatabaseDBObjectType,
  TDBObjectType::TableDBObjectType,
  TDBObjectType::DashboardDBObjectType,
  TDBObjectType::ViewDBObjectType
};
const char* _kTDBObjectTypeNames[] = {
  "AbstractDBObjectType",
  "DatabaseDBObjectType",
  "TableDBObjectType",
  "DashboardDBObjectType",
  "ViewDBObjectType"
};
const std::map<int, const char*> _TDBObjectType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kTDBObjectTypeValues, _kTDBObjectTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TDBObjectType::type& val) {
  std::map<int, const char*>::const_iterator it = _TDBObjectType_VALUES_TO_NAMES.find(val);
  if (it != _TDBObjectType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}


TDatumVal::~TDatumVal() throw() {
}


void TDatumVal::__set_int_val(const int64_t val) {
  this->int_val = val;
}

void TDatumVal::__set_real_val(const double val) {
  this->real_val = val;
}

void TDatumVal::__set_str_val(const std::string& val) {
  this->str_val = val;
}

void TDatumVal::__set_arr_val(const std::vector<TDatum> & val) {
  this->arr_val = val;
}
std::ostream& operator<<(std::ostream& out, const TDatumVal& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TDatumVal::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->int_val);
          this->__isset.int_val = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->real_val);
          this->__isset.real_val = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->str_val);
          this->__isset.str_val = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->arr_val.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _etype3;
            xfer += iprot->readListBegin(_etype3, _size0);
            this->arr_val.resize(_size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              xfer += this->arr_val[_i4].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.arr_val = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TDatumVal::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDatumVal");

  xfer += oprot->writeFieldBegin("int_val", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->int_val);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("real_val", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->real_val);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("str_val", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->str_val);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("arr_val", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->arr_val.size()));
    std::vector<TDatum> ::const_iterator _iter5;
    for (_iter5 = this->arr_val.begin(); _iter5 != this->arr_val.end(); ++_iter5)
    {
      xfer += (*_iter5).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDatumVal &a, TDatumVal &b) {
  using ::std::swap;
  swap(a.int_val, b.int_val);
  swap(a.real_val, b.real_val);
  swap(a.str_val, b.str_val);
  swap(a.arr_val, b.arr_val);
  swap(a.__isset, b.__isset);
}

TDatumVal::TDatumVal(const TDatumVal& other6) {
  int_val = other6.int_val;
  real_val = other6.real_val;
  str_val = other6.str_val;
  arr_val = other6.arr_val;
  __isset = other6.__isset;
}
TDatumVal& TDatumVal::operator=(const TDatumVal& other7) {
  int_val = other7.int_val;
  real_val = other7.real_val;
  str_val = other7.str_val;
  arr_val = other7.arr_val;
  __isset = other7.__isset;
  return *this;
}
void TDatumVal::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDatumVal(";
  out << "int_val=" << to_string(int_val);
  out << ", " << "real_val=" << to_string(real_val);
  out << ", " << "str_val=" << to_string(str_val);
  out << ", " << "arr_val=" << to_string(arr_val);
  out << ")";
}


TDatum::~TDatum() throw() {
}


void TDatum::__set_val(const TDatumVal& val) {
  this->val = val;
}

void TDatum::__set_is_null(const bool val) {
  this->is_null = val;
}
std::ostream& operator<<(std::ostream& out, const TDatum& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TDatum::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->val.read(iprot);
          this->__isset.val = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_null);
          this->__isset.is_null = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TDatum::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDatum");

  xfer += oprot->writeFieldBegin("val", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->val.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_null", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->is_null);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDatum &a, TDatum &b) {
  using ::std::swap;
  swap(a.val, b.val);
  swap(a.is_null, b.is_null);
  swap(a.__isset, b.__isset);
}

TDatum::TDatum(const TDatum& other8) {
  val = other8.val;
  is_null = other8.is_null;
  __isset = other8.__isset;
}
TDatum& TDatum::operator=(const TDatum& other9) {
  val = other9.val;
  is_null = other9.is_null;
  __isset = other9.__isset;
  return *this;
}
void TDatum::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDatum(";
  out << "val=" << to_string(val);
  out << ", " << "is_null=" << to_string(is_null);
  out << ")";
}


TStringValue::~TStringValue() throw() {
}


void TStringValue::__set_str_val(const std::string& val) {
  this->str_val = val;
}

void TStringValue::__set_is_null(const bool val) {
  this->is_null = val;
}
std::ostream& operator<<(std::ostream& out, const TStringValue& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TStringValue::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->str_val);
          this->__isset.str_val = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_null);
          this->__isset.is_null = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TStringValue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TStringValue");

  xfer += oprot->writeFieldBegin("str_val", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->str_val);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_null", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->is_null);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TStringValue &a, TStringValue &b) {
  using ::std::swap;
  swap(a.str_val, b.str_val);
  swap(a.is_null, b.is_null);
  swap(a.__isset, b.__isset);
}

TStringValue::TStringValue(const TStringValue& other10) {
  str_val = other10.str_val;
  is_null = other10.is_null;
  __isset = other10.__isset;
}
TStringValue& TStringValue::operator=(const TStringValue& other11) {
  str_val = other11.str_val;
  is_null = other11.is_null;
  __isset = other11.__isset;
  return *this;
}
void TStringValue::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TStringValue(";
  out << "str_val=" << to_string(str_val);
  out << ", " << "is_null=" << to_string(is_null);
  out << ")";
}


TTypeInfo::~TTypeInfo() throw() {
}


void TTypeInfo::__set_type(const TDatumType::type val) {
  this->type = val;
}

void TTypeInfo::__set_encoding(const TEncodingType::type val) {
  this->encoding = val;
}

void TTypeInfo::__set_nullable(const bool val) {
  this->nullable = val;
}

void TTypeInfo::__set_is_array(const bool val) {
  this->is_array = val;
}

void TTypeInfo::__set_precision(const int32_t val) {
  this->precision = val;
}

void TTypeInfo::__set_scale(const int32_t val) {
  this->scale = val;
}

void TTypeInfo::__set_comp_param(const int32_t val) {
  this->comp_param = val;
}
std::ostream& operator<<(std::ostream& out, const TTypeInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TTypeInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast12;
          xfer += iprot->readI32(ecast12);
          this->type = (TDatumType::type)ecast12;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast13;
          xfer += iprot->readI32(ecast13);
          this->encoding = (TEncodingType::type)ecast13;
          this->__isset.encoding = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->nullable);
          this->__isset.nullable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_array);
          this->__isset.is_array = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->precision);
          this->__isset.precision = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->scale);
          this->__isset.scale = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->comp_param);
          this->__isset.comp_param = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TTypeInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TTypeInfo");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nullable", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->nullable);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_array", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->is_array);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("encoding", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->encoding);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("precision", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->precision);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("scale", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->scale);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("comp_param", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->comp_param);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTypeInfo &a, TTypeInfo &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.encoding, b.encoding);
  swap(a.nullable, b.nullable);
  swap(a.is_array, b.is_array);
  swap(a.precision, b.precision);
  swap(a.scale, b.scale);
  swap(a.comp_param, b.comp_param);
  swap(a.__isset, b.__isset);
}

TTypeInfo::TTypeInfo(const TTypeInfo& other14) {
  type = other14.type;
  encoding = other14.encoding;
  nullable = other14.nullable;
  is_array = other14.is_array;
  precision = other14.precision;
  scale = other14.scale;
  comp_param = other14.comp_param;
  __isset = other14.__isset;
}
TTypeInfo& TTypeInfo::operator=(const TTypeInfo& other15) {
  type = other15.type;
  encoding = other15.encoding;
  nullable = other15.nullable;
  is_array = other15.is_array;
  precision = other15.precision;
  scale = other15.scale;
  comp_param = other15.comp_param;
  __isset = other15.__isset;
  return *this;
}
void TTypeInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TTypeInfo(";
  out << "type=" << to_string(type);
  out << ", " << "encoding=" << to_string(encoding);
  out << ", " << "nullable=" << to_string(nullable);
  out << ", " << "is_array=" << to_string(is_array);
  out << ", " << "precision=" << to_string(precision);
  out << ", " << "scale=" << to_string(scale);
  out << ", " << "comp_param=" << to_string(comp_param);
  out << ")";
}


TColumnType::~TColumnType() throw() {
}


void TColumnType::__set_col_name(const std::string& val) {
  this->col_name = val;
}

void TColumnType::__set_col_type(const TTypeInfo& val) {
  this->col_type = val;
}

void TColumnType::__set_is_reserved_keyword(const bool val) {
  this->is_reserved_keyword = val;
}

void TColumnType::__set_src_name(const std::string& val) {
  this->src_name = val;
}

void TColumnType::__set_is_system(const bool val) {
  this->is_system = val;
}

void TColumnType::__set_is_physical(const bool val) {
  this->is_physical = val;
}
std::ostream& operator<<(std::ostream& out, const TColumnType& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TColumnType::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->col_name);
          this->__isset.col_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->col_type.read(iprot);
          this->__isset.col_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_reserved_keyword);
          this->__isset.is_reserved_keyword = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->src_name);
          this->__isset.src_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_system);
          this->__isset.is_system = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_physical);
          this->__isset.is_physical = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TColumnType::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TColumnType");

  xfer += oprot->writeFieldBegin("col_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->col_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("col_type", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->col_type.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_reserved_keyword", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->is_reserved_keyword);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("src_name", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->src_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_system", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->is_system);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_physical", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool(this->is_physical);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TColumnType &a, TColumnType &b) {
  using ::std::swap;
  swap(a.col_name, b.col_name);
  swap(a.col_type, b.col_type);
  swap(a.is_reserved_keyword, b.is_reserved_keyword);
  swap(a.src_name, b.src_name);
  swap(a.is_system, b.is_system);
  swap(a.is_physical, b.is_physical);
  swap(a.__isset, b.__isset);
}

TColumnType::TColumnType(const TColumnType& other16) {
  col_name = other16.col_name;
  col_type = other16.col_type;
  is_reserved_keyword = other16.is_reserved_keyword;
  src_name = other16.src_name;
  is_system = other16.is_system;
  is_physical = other16.is_physical;
  __isset = other16.__isset;
}
TColumnType& TColumnType::operator=(const TColumnType& other17) {
  col_name = other17.col_name;
  col_type = other17.col_type;
  is_reserved_keyword = other17.is_reserved_keyword;
  src_name = other17.src_name;
  is_system = other17.is_system;
  is_physical = other17.is_physical;
  __isset = other17.__isset;
  return *this;
}
void TColumnType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TColumnType(";
  out << "col_name=" << to_string(col_name);
  out << ", " << "col_type=" << to_string(col_type);
  out << ", " << "is_reserved_keyword=" << to_string(is_reserved_keyword);
  out << ", " << "src_name=" << to_string(src_name);
  out << ", " << "is_system=" << to_string(is_system);
  out << ", " << "is_physical=" << to_string(is_physical);
  out << ")";
}


TRow::~TRow() throw() {
}


void TRow::__set_cols(const std::vector<TDatum> & val) {
  this->cols = val;
}
std::ostream& operator<<(std::ostream& out, const TRow& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TRow::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cols.clear();
            uint32_t _size18;
            ::apache::thrift::protocol::TType _etype21;
            xfer += iprot->readListBegin(_etype21, _size18);
            this->cols.resize(_size18);
            uint32_t _i22;
            for (_i22 = 0; _i22 < _size18; ++_i22)
            {
              xfer += this->cols[_i22].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cols = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TRow::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TRow");

  xfer += oprot->writeFieldBegin("cols", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cols.size()));
    std::vector<TDatum> ::const_iterator _iter23;
    for (_iter23 = this->cols.begin(); _iter23 != this->cols.end(); ++_iter23)
    {
      xfer += (*_iter23).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TRow &a, TRow &b) {
  using ::std::swap;
  swap(a.cols, b.cols);
  swap(a.__isset, b.__isset);
}

TRow::TRow(const TRow& other24) {
  cols = other24.cols;
  __isset = other24.__isset;
}
TRow& TRow::operator=(const TRow& other25) {
  cols = other25.cols;
  __isset = other25.__isset;
  return *this;
}
void TRow::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TRow(";
  out << "cols=" << to_string(cols);
  out << ")";
}


TColumnData::~TColumnData() throw() {
}


void TColumnData::__set_int_col(const std::vector<int64_t> & val) {
  this->int_col = val;
}

void TColumnData::__set_real_col(const std::vector<double> & val) {
  this->real_col = val;
}

void TColumnData::__set_str_col(const std::vector<std::string> & val) {
  this->str_col = val;
}

void TColumnData::__set_arr_col(const std::vector<TColumn> & val) {
  this->arr_col = val;
}
std::ostream& operator<<(std::ostream& out, const TColumnData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TColumnData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->int_col.clear();
            uint32_t _size26;
            ::apache::thrift::protocol::TType _etype29;
            xfer += iprot->readListBegin(_etype29, _size26);
            this->int_col.resize(_size26);
            uint32_t _i30;
            for (_i30 = 0; _i30 < _size26; ++_i30)
            {
              xfer += iprot->readI64(this->int_col[_i30]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.int_col = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->real_col.clear();
            uint32_t _size31;
            ::apache::thrift::protocol::TType _etype34;
            xfer += iprot->readListBegin(_etype34, _size31);
            this->real_col.resize(_size31);
            uint32_t _i35;
            for (_i35 = 0; _i35 < _size31; ++_i35)
            {
              xfer += iprot->readDouble(this->real_col[_i35]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.real_col = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->str_col.clear();
            uint32_t _size36;
            ::apache::thrift::protocol::TType _etype39;
            xfer += iprot->readListBegin(_etype39, _size36);
            this->str_col.resize(_size36);
            uint32_t _i40;
            for (_i40 = 0; _i40 < _size36; ++_i40)
            {
              xfer += iprot->readString(this->str_col[_i40]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.str_col = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->arr_col.clear();
            uint32_t _size41;
            ::apache::thrift::protocol::TType _etype44;
            xfer += iprot->readListBegin(_etype44, _size41);
            this->arr_col.resize(_size41);
            uint32_t _i45;
            for (_i45 = 0; _i45 < _size41; ++_i45)
            {
              xfer += this->arr_col[_i45].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.arr_col = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TColumnData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TColumnData");

  xfer += oprot->writeFieldBegin("int_col", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->int_col.size()));
    std::vector<int64_t> ::const_iterator _iter46;
    for (_iter46 = this->int_col.begin(); _iter46 != this->int_col.end(); ++_iter46)
    {
      xfer += oprot->writeI64((*_iter46));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("real_col", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->real_col.size()));
    std::vector<double> ::const_iterator _iter47;
    for (_iter47 = this->real_col.begin(); _iter47 != this->real_col.end(); ++_iter47)
    {
      xfer += oprot->writeDouble((*_iter47));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("str_col", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->str_col.size()));
    std::vector<std::string> ::const_iterator _iter48;
    for (_iter48 = this->str_col.begin(); _iter48 != this->str_col.end(); ++_iter48)
    {
      xfer += oprot->writeString((*_iter48));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("arr_col", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->arr_col.size()));
    std::vector<TColumn> ::const_iterator _iter49;
    for (_iter49 = this->arr_col.begin(); _iter49 != this->arr_col.end(); ++_iter49)
    {
      xfer += (*_iter49).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TColumnData &a, TColumnData &b) {
  using ::std::swap;
  swap(a.int_col, b.int_col);
  swap(a.real_col, b.real_col);
  swap(a.str_col, b.str_col);
  swap(a.arr_col, b.arr_col);
  swap(a.__isset, b.__isset);
}

TColumnData::TColumnData(const TColumnData& other50) {
  int_col = other50.int_col;
  real_col = other50.real_col;
  str_col = other50.str_col;
  arr_col = other50.arr_col;
  __isset = other50.__isset;
}
TColumnData& TColumnData::operator=(const TColumnData& other51) {
  int_col = other51.int_col;
  real_col = other51.real_col;
  str_col = other51.str_col;
  arr_col = other51.arr_col;
  __isset = other51.__isset;
  return *this;
}
void TColumnData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TColumnData(";
  out << "int_col=" << to_string(int_col);
  out << ", " << "real_col=" << to_string(real_col);
  out << ", " << "str_col=" << to_string(str_col);
  out << ", " << "arr_col=" << to_string(arr_col);
  out << ")";
}


TColumn::~TColumn() throw() {
}


void TColumn::__set_data(const TColumnData& val) {
  this->data = val;
}

void TColumn::__set_nulls(const std::vector<bool> & val) {
  this->nulls = val;
}
std::ostream& operator<<(std::ostream& out, const TColumn& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TColumn::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->nulls.clear();
            uint32_t _size52;
            ::apache::thrift::protocol::TType _etype55;
            xfer += iprot->readListBegin(_etype55, _size52);
            this->nulls.resize(_size52);
            uint32_t _i56;
            for (_i56 = 0; _i56 < _size52; ++_i56)
            {
              xfer += iprot->readBool(this->nulls[_i56]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.nulls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TColumn::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TColumn");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nulls", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>(this->nulls.size()));
    std::vector<bool> ::const_iterator _iter57;
    for (_iter57 = this->nulls.begin(); _iter57 != this->nulls.end(); ++_iter57)
    {
      xfer += oprot->writeBool((*_iter57));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TColumn &a, TColumn &b) {
  using ::std::swap;
  swap(a.data, b.data);
  swap(a.nulls, b.nulls);
  swap(a.__isset, b.__isset);
}

TColumn::TColumn(const TColumn& other58) {
  data = other58.data;
  nulls = other58.nulls;
  __isset = other58.__isset;
}
TColumn& TColumn::operator=(const TColumn& other59) {
  data = other59.data;
  nulls = other59.nulls;
  __isset = other59.__isset;
  return *this;
}
void TColumn::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TColumn(";
  out << "data=" << to_string(data);
  out << ", " << "nulls=" << to_string(nulls);
  out << ")";
}


TStringRow::~TStringRow() throw() {
}


void TStringRow::__set_cols(const std::vector<TStringValue> & val) {
  this->cols = val;
}
std::ostream& operator<<(std::ostream& out, const TStringRow& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TStringRow::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cols.clear();
            uint32_t _size60;
            ::apache::thrift::protocol::TType _etype63;
            xfer += iprot->readListBegin(_etype63, _size60);
            this->cols.resize(_size60);
            uint32_t _i64;
            for (_i64 = 0; _i64 < _size60; ++_i64)
            {
              xfer += this->cols[_i64].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cols = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TStringRow::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TStringRow");

  xfer += oprot->writeFieldBegin("cols", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cols.size()));
    std::vector<TStringValue> ::const_iterator _iter65;
    for (_iter65 = this->cols.begin(); _iter65 != this->cols.end(); ++_iter65)
    {
      xfer += (*_iter65).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TStringRow &a, TStringRow &b) {
  using ::std::swap;
  swap(a.cols, b.cols);
  swap(a.__isset, b.__isset);
}

TStringRow::TStringRow(const TStringRow& other66) {
  cols = other66.cols;
  __isset = other66.__isset;
}
TStringRow& TStringRow::operator=(const TStringRow& other67) {
  cols = other67.cols;
  __isset = other67.__isset;
  return *this;
}
void TStringRow::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TStringRow(";
  out << "cols=" << to_string(cols);
  out << ")";
}


TStepResult::~TStepResult() throw() {
}


void TStepResult::__set_serialized_rows(const std::string& val) {
  this->serialized_rows = val;
}

void TStepResult::__set_execution_finished(const bool val) {
  this->execution_finished = val;
}

void TStepResult::__set_merge_type(const TMergeType::type val) {
  this->merge_type = val;
}

void TStepResult::__set_sharded(const bool val) {
  this->sharded = val;
}

void TStepResult::__set_row_desc(const TRowDescriptor& val) {
  this->row_desc = val;
}

void TStepResult::__set_node_id(const int32_t val) {
  this->node_id = val;
}
std::ostream& operator<<(std::ostream& out, const TStepResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TStepResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->serialized_rows);
          this->__isset.serialized_rows = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->execution_finished);
          this->__isset.execution_finished = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast68;
          xfer += iprot->readI32(ecast68);
          this->merge_type = (TMergeType::type)ecast68;
          this->__isset.merge_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->sharded);
          this->__isset.sharded = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->row_desc.clear();
            uint32_t _size69;
            ::apache::thrift::protocol::TType _etype72;
            xfer += iprot->readListBegin(_etype72, _size69);
            this->row_desc.resize(_size69);
            uint32_t _i73;
            for (_i73 = 0; _i73 < _size69; ++_i73)
            {
              xfer += this->row_desc[_i73].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.row_desc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->node_id);
          this->__isset.node_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TStepResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TStepResult");

  xfer += oprot->writeFieldBegin("serialized_rows", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->serialized_rows);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("execution_finished", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->execution_finished);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("merge_type", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->merge_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sharded", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->sharded);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("row_desc", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->row_desc.size()));
    std::vector<TColumnType> ::const_iterator _iter74;
    for (_iter74 = this->row_desc.begin(); _iter74 != this->row_desc.end(); ++_iter74)
    {
      xfer += (*_iter74).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("node_id", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->node_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TStepResult &a, TStepResult &b) {
  using ::std::swap;
  swap(a.serialized_rows, b.serialized_rows);
  swap(a.execution_finished, b.execution_finished);
  swap(a.merge_type, b.merge_type);
  swap(a.sharded, b.sharded);
  swap(a.row_desc, b.row_desc);
  swap(a.node_id, b.node_id);
  swap(a.__isset, b.__isset);
}

TStepResult::TStepResult(const TStepResult& other75) {
  serialized_rows = other75.serialized_rows;
  execution_finished = other75.execution_finished;
  merge_type = other75.merge_type;
  sharded = other75.sharded;
  row_desc = other75.row_desc;
  node_id = other75.node_id;
  __isset = other75.__isset;
}
TStepResult& TStepResult::operator=(const TStepResult& other76) {
  serialized_rows = other76.serialized_rows;
  execution_finished = other76.execution_finished;
  merge_type = other76.merge_type;
  sharded = other76.sharded;
  row_desc = other76.row_desc;
  node_id = other76.node_id;
  __isset = other76.__isset;
  return *this;
}
void TStepResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TStepResult(";
  out << "serialized_rows=" << to_string(serialized_rows);
  out << ", " << "execution_finished=" << to_string(execution_finished);
  out << ", " << "merge_type=" << to_string(merge_type);
  out << ", " << "sharded=" << to_string(sharded);
  out << ", " << "row_desc=" << to_string(row_desc);
  out << ", " << "node_id=" << to_string(node_id);
  out << ")";
}


TRowSet::~TRowSet() throw() {
}


void TRowSet::__set_row_desc(const TRowDescriptor& val) {
  this->row_desc = val;
}

void TRowSet::__set_rows(const std::vector<TRow> & val) {
  this->rows = val;
}

void TRowSet::__set_columns(const std::vector<TColumn> & val) {
  this->columns = val;
}

void TRowSet::__set_is_columnar(const bool val) {
  this->is_columnar = val;
}
std::ostream& operator<<(std::ostream& out, const TRowSet& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TRowSet::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->row_desc.clear();
            uint32_t _size77;
            ::apache::thrift::protocol::TType _etype80;
            xfer += iprot->readListBegin(_etype80, _size77);
            this->row_desc.resize(_size77);
            uint32_t _i81;
            for (_i81 = 0; _i81 < _size77; ++_i81)
            {
              xfer += this->row_desc[_i81].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.row_desc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->rows.clear();
            uint32_t _size82;
            ::apache::thrift::protocol::TType _etype85;
            xfer += iprot->readListBegin(_etype85, _size82);
            this->rows.resize(_size82);
            uint32_t _i86;
            for (_i86 = 0; _i86 < _size82; ++_i86)
            {
              xfer += this->rows[_i86].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.rows = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size87;
            ::apache::thrift::protocol::TType _etype90;
            xfer += iprot->readListBegin(_etype90, _size87);
            this->columns.resize(_size87);
            uint32_t _i91;
            for (_i91 = 0; _i91 < _size87; ++_i91)
            {
              xfer += this->columns[_i91].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_columnar);
          this->__isset.is_columnar = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TRowSet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TRowSet");

  xfer += oprot->writeFieldBegin("row_desc", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->row_desc.size()));
    std::vector<TColumnType> ::const_iterator _iter92;
    for (_iter92 = this->row_desc.begin(); _iter92 != this->row_desc.end(); ++_iter92)
    {
      xfer += (*_iter92).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rows", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->rows.size()));
    std::vector<TRow> ::const_iterator _iter93;
    for (_iter93 = this->rows.begin(); _iter93 != this->rows.end(); ++_iter93)
    {
      xfer += (*_iter93).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
    std::vector<TColumn> ::const_iterator _iter94;
    for (_iter94 = this->columns.begin(); _iter94 != this->columns.end(); ++_iter94)
    {
      xfer += (*_iter94).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_columnar", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->is_columnar);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TRowSet &a, TRowSet &b) {
  using ::std::swap;
  swap(a.row_desc, b.row_desc);
  swap(a.rows, b.rows);
  swap(a.columns, b.columns);
  swap(a.is_columnar, b.is_columnar);
  swap(a.__isset, b.__isset);
}

TRowSet::TRowSet(const TRowSet& other95) {
  row_desc = other95.row_desc;
  rows = other95.rows;
  columns = other95.columns;
  is_columnar = other95.is_columnar;
  __isset = other95.__isset;
}
TRowSet& TRowSet::operator=(const TRowSet& other96) {
  row_desc = other96.row_desc;
  rows = other96.rows;
  columns = other96.columns;
  is_columnar = other96.is_columnar;
  __isset = other96.__isset;
  return *this;
}
void TRowSet::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TRowSet(";
  out << "row_desc=" << to_string(row_desc);
  out << ", " << "rows=" << to_string(rows);
  out << ", " << "columns=" << to_string(columns);
  out << ", " << "is_columnar=" << to_string(is_columnar);
  out << ")";
}


TQueryResult::~TQueryResult() throw() {
}


void TQueryResult::__set_row_set(const TRowSet& val) {
  this->row_set = val;
}

void TQueryResult::__set_execution_time_ms(const int64_t val) {
  this->execution_time_ms = val;
}

void TQueryResult::__set_total_time_ms(const int64_t val) {
  this->total_time_ms = val;
}

void TQueryResult::__set_nonce(const std::string& val) {
  this->nonce = val;
}
std::ostream& operator<<(std::ostream& out, const TQueryResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TQueryResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->row_set.read(iprot);
          this->__isset.row_set = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->execution_time_ms);
          this->__isset.execution_time_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->total_time_ms);
          this->__isset.total_time_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nonce);
          this->__isset.nonce = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TQueryResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TQueryResult");

  xfer += oprot->writeFieldBegin("row_set", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->row_set.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("execution_time_ms", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->execution_time_ms);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("total_time_ms", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->total_time_ms);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->nonce);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TQueryResult &a, TQueryResult &b) {
  using ::std::swap;
  swap(a.row_set, b.row_set);
  swap(a.execution_time_ms, b.execution_time_ms);
  swap(a.total_time_ms, b.total_time_ms);
  swap(a.nonce, b.nonce);
  swap(a.__isset, b.__isset);
}

TQueryResult::TQueryResult(const TQueryResult& other97) {
  row_set = other97.row_set;
  execution_time_ms = other97.execution_time_ms;
  total_time_ms = other97.total_time_ms;
  nonce = other97.nonce;
  __isset = other97.__isset;
}
TQueryResult& TQueryResult::operator=(const TQueryResult& other98) {
  row_set = other98.row_set;
  execution_time_ms = other98.execution_time_ms;
  total_time_ms = other98.total_time_ms;
  nonce = other98.nonce;
  __isset = other98.__isset;
  return *this;
}
void TQueryResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TQueryResult(";
  out << "row_set=" << to_string(row_set);
  out << ", " << "execution_time_ms=" << to_string(execution_time_ms);
  out << ", " << "total_time_ms=" << to_string(total_time_ms);
  out << ", " << "nonce=" << to_string(nonce);
  out << ")";
}


TDataFrame::~TDataFrame() throw() {
}


void TDataFrame::__set_sm_handle(const std::string& val) {
  this->sm_handle = val;
}

void TDataFrame::__set_sm_size(const int64_t val) {
  this->sm_size = val;
}

void TDataFrame::__set_df_handle(const std::string& val) {
  this->df_handle = val;
}

void TDataFrame::__set_df_size(const int64_t val) {
  this->df_size = val;
}
std::ostream& operator<<(std::ostream& out, const TDataFrame& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TDataFrame::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->sm_handle);
          this->__isset.sm_handle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sm_size);
          this->__isset.sm_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->df_handle);
          this->__isset.df_handle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->df_size);
          this->__isset.df_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TDataFrame::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDataFrame");

  xfer += oprot->writeFieldBegin("sm_handle", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->sm_handle);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sm_size", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->sm_size);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("df_handle", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->df_handle);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("df_size", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->df_size);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDataFrame &a, TDataFrame &b) {
  using ::std::swap;
  swap(a.sm_handle, b.sm_handle);
  swap(a.sm_size, b.sm_size);
  swap(a.df_handle, b.df_handle);
  swap(a.df_size, b.df_size);
  swap(a.__isset, b.__isset);
}

TDataFrame::TDataFrame(const TDataFrame& other99) {
  sm_handle = other99.sm_handle;
  sm_size = other99.sm_size;
  df_handle = other99.df_handle;
  df_size = other99.df_size;
  __isset = other99.__isset;
}
TDataFrame& TDataFrame::operator=(const TDataFrame& other100) {
  sm_handle = other100.sm_handle;
  sm_size = other100.sm_size;
  df_handle = other100.df_handle;
  df_size = other100.df_size;
  __isset = other100.__isset;
  return *this;
}
void TDataFrame::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDataFrame(";
  out << "sm_handle=" << to_string(sm_handle);
  out << ", " << "sm_size=" << to_string(sm_size);
  out << ", " << "df_handle=" << to_string(df_handle);
  out << ", " << "df_size=" << to_string(df_size);
  out << ")";
}


TDBInfo::~TDBInfo() throw() {
}


void TDBInfo::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void TDBInfo::__set_db_owner(const std::string& val) {
  this->db_owner = val;
}
std::ostream& operator<<(std::ostream& out, const TDBInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TDBInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          this->__isset.db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_owner);
          this->__isset.db_owner = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TDBInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDBInfo");

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("db_owner", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->db_owner);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDBInfo &a, TDBInfo &b) {
  using ::std::swap;
  swap(a.db_name, b.db_name);
  swap(a.db_owner, b.db_owner);
  swap(a.__isset, b.__isset);
}

TDBInfo::TDBInfo(const TDBInfo& other101) {
  db_name = other101.db_name;
  db_owner = other101.db_owner;
  __isset = other101.__isset;
}
TDBInfo& TDBInfo::operator=(const TDBInfo& other102) {
  db_name = other102.db_name;
  db_owner = other102.db_owner;
  __isset = other102.__isset;
  return *this;
}
void TDBInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDBInfo(";
  out << "db_name=" << to_string(db_name);
  out << ", " << "db_owner=" << to_string(db_owner);
  out << ")";
}


TMapDException::~TMapDException() throw() {
}


void TMapDException::__set_error_msg(const std::string& val) {
  this->error_msg = val;
}
std::ostream& operator<<(std::ostream& out, const TMapDException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TMapDException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->error_msg);
          this->__isset.error_msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TMapDException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TMapDException");

  xfer += oprot->writeFieldBegin("error_msg", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->error_msg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TMapDException &a, TMapDException &b) {
  using ::std::swap;
  swap(a.error_msg, b.error_msg);
  swap(a.__isset, b.__isset);
}

TMapDException::TMapDException(const TMapDException& other103) : TException() {
  error_msg = other103.error_msg;
  __isset = other103.__isset;
}
TMapDException& TMapDException::operator=(const TMapDException& other104) {
  error_msg = other104.error_msg;
  __isset = other104.__isset;
  return *this;
}
void TMapDException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TMapDException(";
  out << "error_msg=" << to_string(error_msg);
  out << ")";
}

const char* TMapDException::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: TMapDException";
  }
}


TCopyParams::~TCopyParams() throw() {
}


void TCopyParams::__set_delimiter(const std::string& val) {
  this->delimiter = val;
}

void TCopyParams::__set_null_str(const std::string& val) {
  this->null_str = val;
}

void TCopyParams::__set_has_header(const bool val) {
  this->has_header = val;
}

void TCopyParams::__set_quoted(const bool val) {
  this->quoted = val;
}

void TCopyParams::__set_quote(const std::string& val) {
  this->quote = val;
}

void TCopyParams::__set_escape(const std::string& val) {
  this->escape = val;
}

void TCopyParams::__set_line_delim(const std::string& val) {
  this->line_delim = val;
}

void TCopyParams::__set_array_delim(const std::string& val) {
  this->array_delim = val;
}

void TCopyParams::__set_array_begin(const std::string& val) {
  this->array_begin = val;
}

void TCopyParams::__set_array_end(const std::string& val) {
  this->array_end = val;
}

void TCopyParams::__set_threads(const int32_t val) {
  this->threads = val;
}

void TCopyParams::__set_table_type(const TTableType::type val) {
  this->table_type = val;
}

void TCopyParams::__set_s3_access_key(const std::string& val) {
  this->s3_access_key = val;
}

void TCopyParams::__set_s3_secret_key(const std::string& val) {
  this->s3_secret_key = val;
}

void TCopyParams::__set_s3_region(const std::string& val) {
  this->s3_region = val;
}

void TCopyParams::__set_geo_coords_encoding(const TEncodingType::type val) {
  this->geo_coords_encoding = val;
}

void TCopyParams::__set_geo_coords_comp_param(const int32_t val) {
  this->geo_coords_comp_param = val;
}

void TCopyParams::__set_geo_coords_type(const TDatumType::type val) {
  this->geo_coords_type = val;
}

void TCopyParams::__set_geo_coords_srid(const int32_t val) {
  this->geo_coords_srid = val;
}

void TCopyParams::__set_sanitize_column_names(const bool val) {
  this->sanitize_column_names = val;
}
std::ostream& operator<<(std::ostream& out, const TCopyParams& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TCopyParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->delimiter);
          this->__isset.delimiter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->null_str);
          this->__isset.null_str = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->has_header);
          this->__isset.has_header = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->quoted);
          this->__isset.quoted = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->quote);
          this->__isset.quote = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->escape);
          this->__isset.escape = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->line_delim);
          this->__isset.line_delim = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->array_delim);
          this->__isset.array_delim = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->array_begin);
          this->__isset.array_begin = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->array_end);
          this->__isset.array_end = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->threads);
          this->__isset.threads = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast105;
          xfer += iprot->readI32(ecast105);
          this->table_type = (TTableType::type)ecast105;
          this->__isset.table_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->s3_access_key);
          this->__isset.s3_access_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->s3_secret_key);
          this->__isset.s3_secret_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->s3_region);
          this->__isset.s3_region = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast106;
          xfer += iprot->readI32(ecast106);
          this->geo_coords_encoding = (TEncodingType::type)ecast106;
          this->__isset.geo_coords_encoding = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->geo_coords_comp_param);
          this->__isset.geo_coords_comp_param = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast107;
          xfer += iprot->readI32(ecast107);
          this->geo_coords_type = (TDatumType::type)ecast107;
          this->__isset.geo_coords_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->geo_coords_srid);
          this->__isset.geo_coords_srid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->sanitize_column_names);
          this->__isset.sanitize_column_names = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TCopyParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCopyParams");

  xfer += oprot->writeFieldBegin("delimiter", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->delimiter);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("null_str", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->null_str);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("has_header", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->has_header);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("quoted", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->quoted);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("quote", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->quote);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("escape", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->escape);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("line_delim", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->line_delim);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("array_delim", ::apache::thrift::protocol::T_STRING, 8);
  xfer += oprot->writeString(this->array_delim);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("array_begin", ::apache::thrift::protocol::T_STRING, 9);
  xfer += oprot->writeString(this->array_begin);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("array_end", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->array_end);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("threads", ::apache::thrift::protocol::T_I32, 11);
  xfer += oprot->writeI32(this->threads);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_type", ::apache::thrift::protocol::T_I32, 12);
  xfer += oprot->writeI32((int32_t)this->table_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("s3_access_key", ::apache::thrift::protocol::T_STRING, 13);
  xfer += oprot->writeString(this->s3_access_key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("s3_secret_key", ::apache::thrift::protocol::T_STRING, 14);
  xfer += oprot->writeString(this->s3_secret_key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("s3_region", ::apache::thrift::protocol::T_STRING, 15);
  xfer += oprot->writeString(this->s3_region);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("geo_coords_encoding", ::apache::thrift::protocol::T_I32, 16);
  xfer += oprot->writeI32((int32_t)this->geo_coords_encoding);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("geo_coords_comp_param", ::apache::thrift::protocol::T_I32, 17);
  xfer += oprot->writeI32(this->geo_coords_comp_param);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("geo_coords_type", ::apache::thrift::protocol::T_I32, 18);
  xfer += oprot->writeI32((int32_t)this->geo_coords_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("geo_coords_srid", ::apache::thrift::protocol::T_I32, 19);
  xfer += oprot->writeI32(this->geo_coords_srid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sanitize_column_names", ::apache::thrift::protocol::T_BOOL, 20);
  xfer += oprot->writeBool(this->sanitize_column_names);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCopyParams &a, TCopyParams &b) {
  using ::std::swap;
  swap(a.delimiter, b.delimiter);
  swap(a.null_str, b.null_str);
  swap(a.has_header, b.has_header);
  swap(a.quoted, b.quoted);
  swap(a.quote, b.quote);
  swap(a.escape, b.escape);
  swap(a.line_delim, b.line_delim);
  swap(a.array_delim, b.array_delim);
  swap(a.array_begin, b.array_begin);
  swap(a.array_end, b.array_end);
  swap(a.threads, b.threads);
  swap(a.table_type, b.table_type);
  swap(a.s3_access_key, b.s3_access_key);
  swap(a.s3_secret_key, b.s3_secret_key);
  swap(a.s3_region, b.s3_region);
  swap(a.geo_coords_encoding, b.geo_coords_encoding);
  swap(a.geo_coords_comp_param, b.geo_coords_comp_param);
  swap(a.geo_coords_type, b.geo_coords_type);
  swap(a.geo_coords_srid, b.geo_coords_srid);
  swap(a.sanitize_column_names, b.sanitize_column_names);
  swap(a.__isset, b.__isset);
}

TCopyParams::TCopyParams(const TCopyParams& other108) {
  delimiter = other108.delimiter;
  null_str = other108.null_str;
  has_header = other108.has_header;
  quoted = other108.quoted;
  quote = other108.quote;
  escape = other108.escape;
  line_delim = other108.line_delim;
  array_delim = other108.array_delim;
  array_begin = other108.array_begin;
  array_end = other108.array_end;
  threads = other108.threads;
  table_type = other108.table_type;
  s3_access_key = other108.s3_access_key;
  s3_secret_key = other108.s3_secret_key;
  s3_region = other108.s3_region;
  geo_coords_encoding = other108.geo_coords_encoding;
  geo_coords_comp_param = other108.geo_coords_comp_param;
  geo_coords_type = other108.geo_coords_type;
  geo_coords_srid = other108.geo_coords_srid;
  sanitize_column_names = other108.sanitize_column_names;
  __isset = other108.__isset;
}
TCopyParams& TCopyParams::operator=(const TCopyParams& other109) {
  delimiter = other109.delimiter;
  null_str = other109.null_str;
  has_header = other109.has_header;
  quoted = other109.quoted;
  quote = other109.quote;
  escape = other109.escape;
  line_delim = other109.line_delim;
  array_delim = other109.array_delim;
  array_begin = other109.array_begin;
  array_end = other109.array_end;
  threads = other109.threads;
  table_type = other109.table_type;
  s3_access_key = other109.s3_access_key;
  s3_secret_key = other109.s3_secret_key;
  s3_region = other109.s3_region;
  geo_coords_encoding = other109.geo_coords_encoding;
  geo_coords_comp_param = other109.geo_coords_comp_param;
  geo_coords_type = other109.geo_coords_type;
  geo_coords_srid = other109.geo_coords_srid;
  sanitize_column_names = other109.sanitize_column_names;
  __isset = other109.__isset;
  return *this;
}
void TCopyParams::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TCopyParams(";
  out << "delimiter=" << to_string(delimiter);
  out << ", " << "null_str=" << to_string(null_str);
  out << ", " << "has_header=" << to_string(has_header);
  out << ", " << "quoted=" << to_string(quoted);
  out << ", " << "quote=" << to_string(quote);
  out << ", " << "escape=" << to_string(escape);
  out << ", " << "line_delim=" << to_string(line_delim);
  out << ", " << "array_delim=" << to_string(array_delim);
  out << ", " << "array_begin=" << to_string(array_begin);
  out << ", " << "array_end=" << to_string(array_end);
  out << ", " << "threads=" << to_string(threads);
  out << ", " << "table_type=" << to_string(table_type);
  out << ", " << "s3_access_key=" << to_string(s3_access_key);
  out << ", " << "s3_secret_key=" << to_string(s3_secret_key);
  out << ", " << "s3_region=" << to_string(s3_region);
  out << ", " << "geo_coords_encoding=" << to_string(geo_coords_encoding);
  out << ", " << "geo_coords_comp_param=" << to_string(geo_coords_comp_param);
  out << ", " << "geo_coords_type=" << to_string(geo_coords_type);
  out << ", " << "geo_coords_srid=" << to_string(geo_coords_srid);
  out << ", " << "sanitize_column_names=" << to_string(sanitize_column_names);
  out << ")";
}


TDetectResult::~TDetectResult() throw() {
}


void TDetectResult::__set_row_set(const TRowSet& val) {
  this->row_set = val;
}

void TDetectResult::__set_copy_params(const TCopyParams& val) {
  this->copy_params = val;
}
std::ostream& operator<<(std::ostream& out, const TDetectResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TDetectResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->row_set.read(iprot);
          this->__isset.row_set = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->copy_params.read(iprot);
          this->__isset.copy_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TDetectResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDetectResult");

  xfer += oprot->writeFieldBegin("row_set", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->row_set.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("copy_params", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->copy_params.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDetectResult &a, TDetectResult &b) {
  using ::std::swap;
  swap(a.row_set, b.row_set);
  swap(a.copy_params, b.copy_params);
  swap(a.__isset, b.__isset);
}

TDetectResult::TDetectResult(const TDetectResult& other110) {
  row_set = other110.row_set;
  copy_params = other110.copy_params;
  __isset = other110.__isset;
}
TDetectResult& TDetectResult::operator=(const TDetectResult& other111) {
  row_set = other111.row_set;
  copy_params = other111.copy_params;
  __isset = other111.__isset;
  return *this;
}
void TDetectResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDetectResult(";
  out << "row_set=" << to_string(row_set);
  out << ", " << "copy_params=" << to_string(copy_params);
  out << ")";
}


TImportStatus::~TImportStatus() throw() {
}


void TImportStatus::__set_elapsed(const int64_t val) {
  this->elapsed = val;
}

void TImportStatus::__set_rows_completed(const int64_t val) {
  this->rows_completed = val;
}

void TImportStatus::__set_rows_estimated(const int64_t val) {
  this->rows_estimated = val;
}

void TImportStatus::__set_rows_rejected(const int64_t val) {
  this->rows_rejected = val;
}
std::ostream& operator<<(std::ostream& out, const TImportStatus& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TImportStatus::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->elapsed);
          this->__isset.elapsed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->rows_completed);
          this->__isset.rows_completed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->rows_estimated);
          this->__isset.rows_estimated = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->rows_rejected);
          this->__isset.rows_rejected = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TImportStatus::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TImportStatus");

  xfer += oprot->writeFieldBegin("elapsed", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->elapsed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rows_completed", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->rows_completed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rows_estimated", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->rows_estimated);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rows_rejected", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->rows_rejected);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TImportStatus &a, TImportStatus &b) {
  using ::std::swap;
  swap(a.elapsed, b.elapsed);
  swap(a.rows_completed, b.rows_completed);
  swap(a.rows_estimated, b.rows_estimated);
  swap(a.rows_rejected, b.rows_rejected);
  swap(a.__isset, b.__isset);
}

TImportStatus::TImportStatus(const TImportStatus& other112) {
  elapsed = other112.elapsed;
  rows_completed = other112.rows_completed;
  rows_estimated = other112.rows_estimated;
  rows_rejected = other112.rows_rejected;
  __isset = other112.__isset;
}
TImportStatus& TImportStatus::operator=(const TImportStatus& other113) {
  elapsed = other113.elapsed;
  rows_completed = other113.rows_completed;
  rows_estimated = other113.rows_estimated;
  rows_rejected = other113.rows_rejected;
  __isset = other113.__isset;
  return *this;
}
void TImportStatus::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TImportStatus(";
  out << "elapsed=" << to_string(elapsed);
  out << ", " << "rows_completed=" << to_string(rows_completed);
  out << ", " << "rows_estimated=" << to_string(rows_estimated);
  out << ", " << "rows_rejected=" << to_string(rows_rejected);
  out << ")";
}


TFrontendView::~TFrontendView() throw() {
}


void TFrontendView::__set_view_name(const std::string& val) {
  this->view_name = val;
}

void TFrontendView::__set_view_state(const std::string& val) {
  this->view_state = val;
}

void TFrontendView::__set_image_hash(const std::string& val) {
  this->image_hash = val;
}

void TFrontendView::__set_update_time(const std::string& val) {
  this->update_time = val;
}

void TFrontendView::__set_view_metadata(const std::string& val) {
  this->view_metadata = val;
}
std::ostream& operator<<(std::ostream& out, const TFrontendView& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TFrontendView::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->view_name);
          this->__isset.view_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->view_state);
          this->__isset.view_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->image_hash);
          this->__isset.image_hash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->update_time);
          this->__isset.update_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->view_metadata);
          this->__isset.view_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TFrontendView::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TFrontendView");

  xfer += oprot->writeFieldBegin("view_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->view_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("view_state", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->view_state);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("image_hash", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->image_hash);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("update_time", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->update_time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("view_metadata", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->view_metadata);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TFrontendView &a, TFrontendView &b) {
  using ::std::swap;
  swap(a.view_name, b.view_name);
  swap(a.view_state, b.view_state);
  swap(a.image_hash, b.image_hash);
  swap(a.update_time, b.update_time);
  swap(a.view_metadata, b.view_metadata);
  swap(a.__isset, b.__isset);
}

TFrontendView::TFrontendView(const TFrontendView& other114) {
  view_name = other114.view_name;
  view_state = other114.view_state;
  image_hash = other114.image_hash;
  update_time = other114.update_time;
  view_metadata = other114.view_metadata;
  __isset = other114.__isset;
}
TFrontendView& TFrontendView::operator=(const TFrontendView& other115) {
  view_name = other115.view_name;
  view_state = other115.view_state;
  image_hash = other115.image_hash;
  update_time = other115.update_time;
  view_metadata = other115.view_metadata;
  __isset = other115.__isset;
  return *this;
}
void TFrontendView::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TFrontendView(";
  out << "view_name=" << to_string(view_name);
  out << ", " << "view_state=" << to_string(view_state);
  out << ", " << "image_hash=" << to_string(image_hash);
  out << ", " << "update_time=" << to_string(update_time);
  out << ", " << "view_metadata=" << to_string(view_metadata);
  out << ")";
}


TDashboard::~TDashboard() throw() {
}


void TDashboard::__set_dashboard_name(const std::string& val) {
  this->dashboard_name = val;
}

void TDashboard::__set_dashboard_state(const std::string& val) {
  this->dashboard_state = val;
}

void TDashboard::__set_image_hash(const std::string& val) {
  this->image_hash = val;
}

void TDashboard::__set_update_time(const std::string& val) {
  this->update_time = val;
}

void TDashboard::__set_dashboard_metadata(const std::string& val) {
  this->dashboard_metadata = val;
}

void TDashboard::__set_dashboard_id(const int32_t val) {
  this->dashboard_id = val;
}

void TDashboard::__set_dashboard_owner(const std::string& val) {
  this->dashboard_owner = val;
}

void TDashboard::__set_is_dash_shared(const bool val) {
  this->is_dash_shared = val;
}
std::ostream& operator<<(std::ostream& out, const TDashboard& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TDashboard::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dashboard_name);
          this->__isset.dashboard_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dashboard_state);
          this->__isset.dashboard_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->image_hash);
          this->__isset.image_hash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->update_time);
          this->__isset.update_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dashboard_metadata);
          this->__isset.dashboard_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->dashboard_id);
          this->__isset.dashboard_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dashboard_owner);
          this->__isset.dashboard_owner = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_dash_shared);
          this->__isset.is_dash_shared = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TDashboard::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDashboard");

  xfer += oprot->writeFieldBegin("dashboard_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dashboard_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dashboard_state", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dashboard_state);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("image_hash", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->image_hash);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("update_time", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->update_time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dashboard_metadata", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->dashboard_metadata);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dashboard_id", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->dashboard_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dashboard_owner", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->dashboard_owner);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_dash_shared", ::apache::thrift::protocol::T_BOOL, 8);
  xfer += oprot->writeBool(this->is_dash_shared);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDashboard &a, TDashboard &b) {
  using ::std::swap;
  swap(a.dashboard_name, b.dashboard_name);
  swap(a.dashboard_state, b.dashboard_state);
  swap(a.image_hash, b.image_hash);
  swap(a.update_time, b.update_time);
  swap(a.dashboard_metadata, b.dashboard_metadata);
  swap(a.dashboard_id, b.dashboard_id);
  swap(a.dashboard_owner, b.dashboard_owner);
  swap(a.is_dash_shared, b.is_dash_shared);
  swap(a.__isset, b.__isset);
}

TDashboard::TDashboard(const TDashboard& other116) {
  dashboard_name = other116.dashboard_name;
  dashboard_state = other116.dashboard_state;
  image_hash = other116.image_hash;
  update_time = other116.update_time;
  dashboard_metadata = other116.dashboard_metadata;
  dashboard_id = other116.dashboard_id;
  dashboard_owner = other116.dashboard_owner;
  is_dash_shared = other116.is_dash_shared;
  __isset = other116.__isset;
}
TDashboard& TDashboard::operator=(const TDashboard& other117) {
  dashboard_name = other117.dashboard_name;
  dashboard_state = other117.dashboard_state;
  image_hash = other117.image_hash;
  update_time = other117.update_time;
  dashboard_metadata = other117.dashboard_metadata;
  dashboard_id = other117.dashboard_id;
  dashboard_owner = other117.dashboard_owner;
  is_dash_shared = other117.is_dash_shared;
  __isset = other117.__isset;
  return *this;
}
void TDashboard::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDashboard(";
  out << "dashboard_name=" << to_string(dashboard_name);
  out << ", " << "dashboard_state=" << to_string(dashboard_state);
  out << ", " << "image_hash=" << to_string(image_hash);
  out << ", " << "update_time=" << to_string(update_time);
  out << ", " << "dashboard_metadata=" << to_string(dashboard_metadata);
  out << ", " << "dashboard_id=" << to_string(dashboard_id);
  out << ", " << "dashboard_owner=" << to_string(dashboard_owner);
  out << ", " << "is_dash_shared=" << to_string(is_dash_shared);
  out << ")";
}


TServerStatus::~TServerStatus() throw() {
}


void TServerStatus::__set_read_only(const bool val) {
  this->read_only = val;
}

void TServerStatus::__set_version(const std::string& val) {
  this->version = val;
}

void TServerStatus::__set_rendering_enabled(const bool val) {
  this->rendering_enabled = val;
}

void TServerStatus::__set_start_time(const int64_t val) {
  this->start_time = val;
}

void TServerStatus::__set_edition(const std::string& val) {
  this->edition = val;
}

void TServerStatus::__set_host_name(const std::string& val) {
  this->host_name = val;
}

void TServerStatus::__set_poly_rendering_enabled(const bool val) {
  this->poly_rendering_enabled = val;
}
std::ostream& operator<<(std::ostream& out, const TServerStatus& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TServerStatus::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->read_only);
          this->__isset.read_only = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->rendering_enabled);
          this->__isset.rendering_enabled = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->start_time);
          this->__isset.start_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->edition);
          this->__isset.edition = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host_name);
          this->__isset.host_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->poly_rendering_enabled);
          this->__isset.poly_rendering_enabled = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TServerStatus::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TServerStatus");

  xfer += oprot->writeFieldBegin("read_only", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->read_only);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rendering_enabled", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->rendering_enabled);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("start_time", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->start_time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("edition", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->edition);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("host_name", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->host_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("poly_rendering_enabled", ::apache::thrift::protocol::T_BOOL, 7);
  xfer += oprot->writeBool(this->poly_rendering_enabled);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TServerStatus &a, TServerStatus &b) {
  using ::std::swap;
  swap(a.read_only, b.read_only);
  swap(a.version, b.version);
  swap(a.rendering_enabled, b.rendering_enabled);
  swap(a.start_time, b.start_time);
  swap(a.edition, b.edition);
  swap(a.host_name, b.host_name);
  swap(a.poly_rendering_enabled, b.poly_rendering_enabled);
  swap(a.__isset, b.__isset);
}

TServerStatus::TServerStatus(const TServerStatus& other118) {
  read_only = other118.read_only;
  version = other118.version;
  rendering_enabled = other118.rendering_enabled;
  start_time = other118.start_time;
  edition = other118.edition;
  host_name = other118.host_name;
  poly_rendering_enabled = other118.poly_rendering_enabled;
  __isset = other118.__isset;
}
TServerStatus& TServerStatus::operator=(const TServerStatus& other119) {
  read_only = other119.read_only;
  version = other119.version;
  rendering_enabled = other119.rendering_enabled;
  start_time = other119.start_time;
  edition = other119.edition;
  host_name = other119.host_name;
  poly_rendering_enabled = other119.poly_rendering_enabled;
  __isset = other119.__isset;
  return *this;
}
void TServerStatus::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TServerStatus(";
  out << "read_only=" << to_string(read_only);
  out << ", " << "version=" << to_string(version);
  out << ", " << "rendering_enabled=" << to_string(rendering_enabled);
  out << ", " << "start_time=" << to_string(start_time);
  out << ", " << "edition=" << to_string(edition);
  out << ", " << "host_name=" << to_string(host_name);
  out << ", " << "poly_rendering_enabled=" << to_string(poly_rendering_enabled);
  out << ")";
}


TPixel::~TPixel() throw() {
}


void TPixel::__set_x(const int64_t val) {
  this->x = val;
}

void TPixel::__set_y(const int64_t val) {
  this->y = val;
}
std::ostream& operator<<(std::ostream& out, const TPixel& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TPixel::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->x);
          this->__isset.x = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->y);
          this->__isset.y = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TPixel::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TPixel");

  xfer += oprot->writeFieldBegin("x", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->x);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("y", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->y);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TPixel &a, TPixel &b) {
  using ::std::swap;
  swap(a.x, b.x);
  swap(a.y, b.y);
  swap(a.__isset, b.__isset);
}

TPixel::TPixel(const TPixel& other120) {
  x = other120.x;
  y = other120.y;
  __isset = other120.__isset;
}
TPixel& TPixel::operator=(const TPixel& other121) {
  x = other121.x;
  y = other121.y;
  __isset = other121.__isset;
  return *this;
}
void TPixel::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TPixel(";
  out << "x=" << to_string(x);
  out << ", " << "y=" << to_string(y);
  out << ")";
}


TPixelTableRowResult::~TPixelTableRowResult() throw() {
}


void TPixelTableRowResult::__set_pixel(const TPixel& val) {
  this->pixel = val;
}

void TPixelTableRowResult::__set_vega_table_name(const std::string& val) {
  this->vega_table_name = val;
}

void TPixelTableRowResult::__set_table_id(const int64_t val) {
  this->table_id = val;
}

void TPixelTableRowResult::__set_row_id(const int64_t val) {
  this->row_id = val;
}

void TPixelTableRowResult::__set_row_set(const TRowSet& val) {
  this->row_set = val;
}

void TPixelTableRowResult::__set_nonce(const std::string& val) {
  this->nonce = val;
}
std::ostream& operator<<(std::ostream& out, const TPixelTableRowResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TPixelTableRowResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->pixel.read(iprot);
          this->__isset.pixel = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->vega_table_name);
          this->__isset.vega_table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->table_id);
          this->__isset.table_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->row_id);
          this->__isset.row_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->row_set.read(iprot);
          this->__isset.row_set = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nonce);
          this->__isset.nonce = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TPixelTableRowResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TPixelTableRowResult");

  xfer += oprot->writeFieldBegin("pixel", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->pixel.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("vega_table_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->vega_table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_id", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->table_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("row_id", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->row_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("row_set", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->row_set.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->nonce);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TPixelTableRowResult &a, TPixelTableRowResult &b) {
  using ::std::swap;
  swap(a.pixel, b.pixel);
  swap(a.vega_table_name, b.vega_table_name);
  swap(a.table_id, b.table_id);
  swap(a.row_id, b.row_id);
  swap(a.row_set, b.row_set);
  swap(a.nonce, b.nonce);
  swap(a.__isset, b.__isset);
}

TPixelTableRowResult::TPixelTableRowResult(const TPixelTableRowResult& other122) {
  pixel = other122.pixel;
  vega_table_name = other122.vega_table_name;
  table_id = other122.table_id;
  row_id = other122.row_id;
  row_set = other122.row_set;
  nonce = other122.nonce;
  __isset = other122.__isset;
}
TPixelTableRowResult& TPixelTableRowResult::operator=(const TPixelTableRowResult& other123) {
  pixel = other123.pixel;
  vega_table_name = other123.vega_table_name;
  table_id = other123.table_id;
  row_id = other123.row_id;
  row_set = other123.row_set;
  nonce = other123.nonce;
  __isset = other123.__isset;
  return *this;
}
void TPixelTableRowResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TPixelTableRowResult(";
  out << "pixel=" << to_string(pixel);
  out << ", " << "vega_table_name=" << to_string(vega_table_name);
  out << ", " << "table_id=" << to_string(table_id);
  out << ", " << "row_id=" << to_string(row_id);
  out << ", " << "row_set=" << to_string(row_set);
  out << ", " << "nonce=" << to_string(nonce);
  out << ")";
}


TRenderResult::~TRenderResult() throw() {
}


void TRenderResult::__set_image(const std::string& val) {
  this->image = val;
}

void TRenderResult::__set_nonce(const std::string& val) {
  this->nonce = val;
}

void TRenderResult::__set_execution_time_ms(const int64_t val) {
  this->execution_time_ms = val;
}

void TRenderResult::__set_render_time_ms(const int64_t val) {
  this->render_time_ms = val;
}

void TRenderResult::__set_total_time_ms(const int64_t val) {
  this->total_time_ms = val;
}

void TRenderResult::__set_vega_metadata(const std::string& val) {
  this->vega_metadata = val;
}
std::ostream& operator<<(std::ostream& out, const TRenderResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TRenderResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->image);
          this->__isset.image = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nonce);
          this->__isset.nonce = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->execution_time_ms);
          this->__isset.execution_time_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->render_time_ms);
          this->__isset.render_time_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->total_time_ms);
          this->__isset.total_time_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->vega_metadata);
          this->__isset.vega_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TRenderResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TRenderResult");

  xfer += oprot->writeFieldBegin("image", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->image);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->nonce);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("execution_time_ms", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->execution_time_ms);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("render_time_ms", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->render_time_ms);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("total_time_ms", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->total_time_ms);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("vega_metadata", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->vega_metadata);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TRenderResult &a, TRenderResult &b) {
  using ::std::swap;
  swap(a.image, b.image);
  swap(a.nonce, b.nonce);
  swap(a.execution_time_ms, b.execution_time_ms);
  swap(a.render_time_ms, b.render_time_ms);
  swap(a.total_time_ms, b.total_time_ms);
  swap(a.vega_metadata, b.vega_metadata);
  swap(a.__isset, b.__isset);
}

TRenderResult::TRenderResult(const TRenderResult& other124) {
  image = other124.image;
  nonce = other124.nonce;
  execution_time_ms = other124.execution_time_ms;
  render_time_ms = other124.render_time_ms;
  total_time_ms = other124.total_time_ms;
  vega_metadata = other124.vega_metadata;
  __isset = other124.__isset;
}
TRenderResult& TRenderResult::operator=(const TRenderResult& other125) {
  image = other125.image;
  nonce = other125.nonce;
  execution_time_ms = other125.execution_time_ms;
  render_time_ms = other125.render_time_ms;
  total_time_ms = other125.total_time_ms;
  vega_metadata = other125.vega_metadata;
  __isset = other125.__isset;
  return *this;
}
void TRenderResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TRenderResult(";
  out << "image=" << to_string(image);
  out << ", " << "nonce=" << to_string(nonce);
  out << ", " << "execution_time_ms=" << to_string(execution_time_ms);
  out << ", " << "render_time_ms=" << to_string(render_time_ms);
  out << ", " << "total_time_ms=" << to_string(total_time_ms);
  out << ", " << "vega_metadata=" << to_string(vega_metadata);
  out << ")";
}


TGpuSpecification::~TGpuSpecification() throw() {
}


void TGpuSpecification::__set_num_sm(const int32_t val) {
  this->num_sm = val;
}

void TGpuSpecification::__set_clock_frequency_kHz(const int64_t val) {
  this->clock_frequency_kHz = val;
}

void TGpuSpecification::__set_memory(const int64_t val) {
  this->memory = val;
}

void TGpuSpecification::__set_compute_capability_major(const int16_t val) {
  this->compute_capability_major = val;
}

void TGpuSpecification::__set_compute_capability_minor(const int16_t val) {
  this->compute_capability_minor = val;
}
std::ostream& operator<<(std::ostream& out, const TGpuSpecification& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TGpuSpecification::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num_sm);
          this->__isset.num_sm = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->clock_frequency_kHz);
          this->__isset.clock_frequency_kHz = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->memory);
          this->__isset.memory = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->compute_capability_major);
          this->__isset.compute_capability_major = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->compute_capability_minor);
          this->__isset.compute_capability_minor = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TGpuSpecification::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGpuSpecification");

  xfer += oprot->writeFieldBegin("num_sm", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->num_sm);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("clock_frequency_kHz", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->clock_frequency_kHz);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("memory", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->memory);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("compute_capability_major", ::apache::thrift::protocol::T_I16, 4);
  xfer += oprot->writeI16(this->compute_capability_major);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("compute_capability_minor", ::apache::thrift::protocol::T_I16, 5);
  xfer += oprot->writeI16(this->compute_capability_minor);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TGpuSpecification &a, TGpuSpecification &b) {
  using ::std::swap;
  swap(a.num_sm, b.num_sm);
  swap(a.clock_frequency_kHz, b.clock_frequency_kHz);
  swap(a.memory, b.memory);
  swap(a.compute_capability_major, b.compute_capability_major);
  swap(a.compute_capability_minor, b.compute_capability_minor);
  swap(a.__isset, b.__isset);
}

TGpuSpecification::TGpuSpecification(const TGpuSpecification& other126) {
  num_sm = other126.num_sm;
  clock_frequency_kHz = other126.clock_frequency_kHz;
  memory = other126.memory;
  compute_capability_major = other126.compute_capability_major;
  compute_capability_minor = other126.compute_capability_minor;
  __isset = other126.__isset;
}
TGpuSpecification& TGpuSpecification::operator=(const TGpuSpecification& other127) {
  num_sm = other127.num_sm;
  clock_frequency_kHz = other127.clock_frequency_kHz;
  memory = other127.memory;
  compute_capability_major = other127.compute_capability_major;
  compute_capability_minor = other127.compute_capability_minor;
  __isset = other127.__isset;
  return *this;
}
void TGpuSpecification::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TGpuSpecification(";
  out << "num_sm=" << to_string(num_sm);
  out << ", " << "clock_frequency_kHz=" << to_string(clock_frequency_kHz);
  out << ", " << "memory=" << to_string(memory);
  out << ", " << "compute_capability_major=" << to_string(compute_capability_major);
  out << ", " << "compute_capability_minor=" << to_string(compute_capability_minor);
  out << ")";
}


THardwareInfo::~THardwareInfo() throw() {
}


void THardwareInfo::__set_num_gpu_hw(const int16_t val) {
  this->num_gpu_hw = val;
}

void THardwareInfo::__set_num_cpu_hw(const int16_t val) {
  this->num_cpu_hw = val;
}

void THardwareInfo::__set_num_gpu_allocated(const int16_t val) {
  this->num_gpu_allocated = val;
}

void THardwareInfo::__set_start_gpu(const int16_t val) {
  this->start_gpu = val;
}

void THardwareInfo::__set_host_name(const std::string& val) {
  this->host_name = val;
}

void THardwareInfo::__set_gpu_info(const std::vector<TGpuSpecification> & val) {
  this->gpu_info = val;
}
std::ostream& operator<<(std::ostream& out, const THardwareInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t THardwareInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->num_gpu_hw);
          this->__isset.num_gpu_hw = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->num_cpu_hw);
          this->__isset.num_cpu_hw = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->num_gpu_allocated);
          this->__isset.num_gpu_allocated = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->start_gpu);
          this->__isset.start_gpu = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host_name);
          this->__isset.host_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->gpu_info.clear();
            uint32_t _size128;
            ::apache::thrift::protocol::TType _etype131;
            xfer += iprot->readListBegin(_etype131, _size128);
            this->gpu_info.resize(_size128);
            uint32_t _i132;
            for (_i132 = 0; _i132 < _size128; ++_i132)
            {
              xfer += this->gpu_info[_i132].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.gpu_info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t THardwareInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("THardwareInfo");

  xfer += oprot->writeFieldBegin("num_gpu_hw", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->num_gpu_hw);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num_cpu_hw", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->num_cpu_hw);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num_gpu_allocated", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16(this->num_gpu_allocated);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("start_gpu", ::apache::thrift::protocol::T_I16, 4);
  xfer += oprot->writeI16(this->start_gpu);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("host_name", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->host_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("gpu_info", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->gpu_info.size()));
    std::vector<TGpuSpecification> ::const_iterator _iter133;
    for (_iter133 = this->gpu_info.begin(); _iter133 != this->gpu_info.end(); ++_iter133)
    {
      xfer += (*_iter133).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(THardwareInfo &a, THardwareInfo &b) {
  using ::std::swap;
  swap(a.num_gpu_hw, b.num_gpu_hw);
  swap(a.num_cpu_hw, b.num_cpu_hw);
  swap(a.num_gpu_allocated, b.num_gpu_allocated);
  swap(a.start_gpu, b.start_gpu);
  swap(a.host_name, b.host_name);
  swap(a.gpu_info, b.gpu_info);
  swap(a.__isset, b.__isset);
}

THardwareInfo::THardwareInfo(const THardwareInfo& other134) {
  num_gpu_hw = other134.num_gpu_hw;
  num_cpu_hw = other134.num_cpu_hw;
  num_gpu_allocated = other134.num_gpu_allocated;
  start_gpu = other134.start_gpu;
  host_name = other134.host_name;
  gpu_info = other134.gpu_info;
  __isset = other134.__isset;
}
THardwareInfo& THardwareInfo::operator=(const THardwareInfo& other135) {
  num_gpu_hw = other135.num_gpu_hw;
  num_cpu_hw = other135.num_cpu_hw;
  num_gpu_allocated = other135.num_gpu_allocated;
  start_gpu = other135.start_gpu;
  host_name = other135.host_name;
  gpu_info = other135.gpu_info;
  __isset = other135.__isset;
  return *this;
}
void THardwareInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "THardwareInfo(";
  out << "num_gpu_hw=" << to_string(num_gpu_hw);
  out << ", " << "num_cpu_hw=" << to_string(num_cpu_hw);
  out << ", " << "num_gpu_allocated=" << to_string(num_gpu_allocated);
  out << ", " << "start_gpu=" << to_string(start_gpu);
  out << ", " << "host_name=" << to_string(host_name);
  out << ", " << "gpu_info=" << to_string(gpu_info);
  out << ")";
}


TClusterHardwareInfo::~TClusterHardwareInfo() throw() {
}


void TClusterHardwareInfo::__set_hardware_info(const std::vector<THardwareInfo> & val) {
  this->hardware_info = val;
}
std::ostream& operator<<(std::ostream& out, const TClusterHardwareInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TClusterHardwareInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->hardware_info.clear();
            uint32_t _size136;
            ::apache::thrift::protocol::TType _etype139;
            xfer += iprot->readListBegin(_etype139, _size136);
            this->hardware_info.resize(_size136);
            uint32_t _i140;
            for (_i140 = 0; _i140 < _size136; ++_i140)
            {
              xfer += this->hardware_info[_i140].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.hardware_info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TClusterHardwareInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TClusterHardwareInfo");

  xfer += oprot->writeFieldBegin("hardware_info", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->hardware_info.size()));
    std::vector<THardwareInfo> ::const_iterator _iter141;
    for (_iter141 = this->hardware_info.begin(); _iter141 != this->hardware_info.end(); ++_iter141)
    {
      xfer += (*_iter141).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TClusterHardwareInfo &a, TClusterHardwareInfo &b) {
  using ::std::swap;
  swap(a.hardware_info, b.hardware_info);
  swap(a.__isset, b.__isset);
}

TClusterHardwareInfo::TClusterHardwareInfo(const TClusterHardwareInfo& other142) {
  hardware_info = other142.hardware_info;
  __isset = other142.__isset;
}
TClusterHardwareInfo& TClusterHardwareInfo::operator=(const TClusterHardwareInfo& other143) {
  hardware_info = other143.hardware_info;
  __isset = other143.__isset;
  return *this;
}
void TClusterHardwareInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TClusterHardwareInfo(";
  out << "hardware_info=" << to_string(hardware_info);
  out << ")";
}


TMemoryData::~TMemoryData() throw() {
}


void TMemoryData::__set_slab(const int64_t val) {
  this->slab = val;
}

void TMemoryData::__set_start_page(const int32_t val) {
  this->start_page = val;
}

void TMemoryData::__set_num_pages(const int64_t val) {
  this->num_pages = val;
}

void TMemoryData::__set_touch(const int32_t val) {
  this->touch = val;
}

void TMemoryData::__set_chunk_key(const std::vector<int64_t> & val) {
  this->chunk_key = val;
}

void TMemoryData::__set_buffer_epoch(const int32_t val) {
  this->buffer_epoch = val;
}

void TMemoryData::__set_is_free(const bool val) {
  this->is_free = val;
}
std::ostream& operator<<(std::ostream& out, const TMemoryData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TMemoryData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->slab);
          this->__isset.slab = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->start_page);
          this->__isset.start_page = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->num_pages);
          this->__isset.num_pages = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->touch);
          this->__isset.touch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->chunk_key.clear();
            uint32_t _size144;
            ::apache::thrift::protocol::TType _etype147;
            xfer += iprot->readListBegin(_etype147, _size144);
            this->chunk_key.resize(_size144);
            uint32_t _i148;
            for (_i148 = 0; _i148 < _size144; ++_i148)
            {
              xfer += iprot->readI64(this->chunk_key[_i148]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.chunk_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->buffer_epoch);
          this->__isset.buffer_epoch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_free);
          this->__isset.is_free = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TMemoryData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TMemoryData");

  xfer += oprot->writeFieldBegin("slab", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->slab);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("start_page", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->start_page);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num_pages", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->num_pages);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("touch", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->touch);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("chunk_key", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->chunk_key.size()));
    std::vector<int64_t> ::const_iterator _iter149;
    for (_iter149 = this->chunk_key.begin(); _iter149 != this->chunk_key.end(); ++_iter149)
    {
      xfer += oprot->writeI64((*_iter149));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("buffer_epoch", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->buffer_epoch);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_free", ::apache::thrift::protocol::T_BOOL, 7);
  xfer += oprot->writeBool(this->is_free);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TMemoryData &a, TMemoryData &b) {
  using ::std::swap;
  swap(a.slab, b.slab);
  swap(a.start_page, b.start_page);
  swap(a.num_pages, b.num_pages);
  swap(a.touch, b.touch);
  swap(a.chunk_key, b.chunk_key);
  swap(a.buffer_epoch, b.buffer_epoch);
  swap(a.is_free, b.is_free);
  swap(a.__isset, b.__isset);
}

TMemoryData::TMemoryData(const TMemoryData& other150) {
  slab = other150.slab;
  start_page = other150.start_page;
  num_pages = other150.num_pages;
  touch = other150.touch;
  chunk_key = other150.chunk_key;
  buffer_epoch = other150.buffer_epoch;
  is_free = other150.is_free;
  __isset = other150.__isset;
}
TMemoryData& TMemoryData::operator=(const TMemoryData& other151) {
  slab = other151.slab;
  start_page = other151.start_page;
  num_pages = other151.num_pages;
  touch = other151.touch;
  chunk_key = other151.chunk_key;
  buffer_epoch = other151.buffer_epoch;
  is_free = other151.is_free;
  __isset = other151.__isset;
  return *this;
}
void TMemoryData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TMemoryData(";
  out << "slab=" << to_string(slab);
  out << ", " << "start_page=" << to_string(start_page);
  out << ", " << "num_pages=" << to_string(num_pages);
  out << ", " << "touch=" << to_string(touch);
  out << ", " << "chunk_key=" << to_string(chunk_key);
  out << ", " << "buffer_epoch=" << to_string(buffer_epoch);
  out << ", " << "is_free=" << to_string(is_free);
  out << ")";
}


TNodeMemoryInfo::~TNodeMemoryInfo() throw() {
}


void TNodeMemoryInfo::__set_host_name(const std::string& val) {
  this->host_name = val;
}

void TNodeMemoryInfo::__set_page_size(const int64_t val) {
  this->page_size = val;
}

void TNodeMemoryInfo::__set_max_num_pages(const int64_t val) {
  this->max_num_pages = val;
}

void TNodeMemoryInfo::__set_num_pages_allocated(const int64_t val) {
  this->num_pages_allocated = val;
}

void TNodeMemoryInfo::__set_is_allocation_capped(const bool val) {
  this->is_allocation_capped = val;
}

void TNodeMemoryInfo::__set_node_memory_data(const std::vector<TMemoryData> & val) {
  this->node_memory_data = val;
}
std::ostream& operator<<(std::ostream& out, const TNodeMemoryInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TNodeMemoryInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host_name);
          this->__isset.host_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->page_size);
          this->__isset.page_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->max_num_pages);
          this->__isset.max_num_pages = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->num_pages_allocated);
          this->__isset.num_pages_allocated = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_allocation_capped);
          this->__isset.is_allocation_capped = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->node_memory_data.clear();
            uint32_t _size152;
            ::apache::thrift::protocol::TType _etype155;
            xfer += iprot->readListBegin(_etype155, _size152);
            this->node_memory_data.resize(_size152);
            uint32_t _i156;
            for (_i156 = 0; _i156 < _size152; ++_i156)
            {
              xfer += this->node_memory_data[_i156].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.node_memory_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TNodeMemoryInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TNodeMemoryInfo");

  xfer += oprot->writeFieldBegin("host_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->host_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("page_size", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->page_size);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("max_num_pages", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->max_num_pages);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num_pages_allocated", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->num_pages_allocated);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_allocation_capped", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->is_allocation_capped);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("node_memory_data", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->node_memory_data.size()));
    std::vector<TMemoryData> ::const_iterator _iter157;
    for (_iter157 = this->node_memory_data.begin(); _iter157 != this->node_memory_data.end(); ++_iter157)
    {
      xfer += (*_iter157).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TNodeMemoryInfo &a, TNodeMemoryInfo &b) {
  using ::std::swap;
  swap(a.host_name, b.host_name);
  swap(a.page_size, b.page_size);
  swap(a.max_num_pages, b.max_num_pages);
  swap(a.num_pages_allocated, b.num_pages_allocated);
  swap(a.is_allocation_capped, b.is_allocation_capped);
  swap(a.node_memory_data, b.node_memory_data);
  swap(a.__isset, b.__isset);
}

TNodeMemoryInfo::TNodeMemoryInfo(const TNodeMemoryInfo& other158) {
  host_name = other158.host_name;
  page_size = other158.page_size;
  max_num_pages = other158.max_num_pages;
  num_pages_allocated = other158.num_pages_allocated;
  is_allocation_capped = other158.is_allocation_capped;
  node_memory_data = other158.node_memory_data;
  __isset = other158.__isset;
}
TNodeMemoryInfo& TNodeMemoryInfo::operator=(const TNodeMemoryInfo& other159) {
  host_name = other159.host_name;
  page_size = other159.page_size;
  max_num_pages = other159.max_num_pages;
  num_pages_allocated = other159.num_pages_allocated;
  is_allocation_capped = other159.is_allocation_capped;
  node_memory_data = other159.node_memory_data;
  __isset = other159.__isset;
  return *this;
}
void TNodeMemoryInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TNodeMemoryInfo(";
  out << "host_name=" << to_string(host_name);
  out << ", " << "page_size=" << to_string(page_size);
  out << ", " << "max_num_pages=" << to_string(max_num_pages);
  out << ", " << "num_pages_allocated=" << to_string(num_pages_allocated);
  out << ", " << "is_allocation_capped=" << to_string(is_allocation_capped);
  out << ", " << "node_memory_data=" << to_string(node_memory_data);
  out << ")";
}


TTableMeta::~TTableMeta() throw() {
}


void TTableMeta::__set_table_name(const std::string& val) {
  this->table_name = val;
}

void TTableMeta::__set_num_cols(const int64_t val) {
  this->num_cols = val;
}

void TTableMeta::__set_col_datum_types(const std::vector<TDatumType::type> & val) {
  this->col_datum_types = val;
}

void TTableMeta::__set_is_view(const bool val) {
  this->is_view = val;
}

void TTableMeta::__set_is_replicated(const bool val) {
  this->is_replicated = val;
}

void TTableMeta::__set_shard_count(const int64_t val) {
  this->shard_count = val;
}

void TTableMeta::__set_max_rows(const int64_t val) {
  this->max_rows = val;
}
std::ostream& operator<<(std::ostream& out, const TTableMeta& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TTableMeta::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          this->__isset.table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->num_cols);
          this->__isset.num_cols = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->col_datum_types.clear();
            uint32_t _size160;
            ::apache::thrift::protocol::TType _etype163;
            xfer += iprot->readListBegin(_etype163, _size160);
            this->col_datum_types.resize(_size160);
            uint32_t _i164;
            for (_i164 = 0; _i164 < _size160; ++_i164)
            {
              int32_t ecast165;
              xfer += iprot->readI32(ecast165);
              this->col_datum_types[_i164] = (TDatumType::type)ecast165;
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.col_datum_types = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_view);
          this->__isset.is_view = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_replicated);
          this->__isset.is_replicated = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->shard_count);
          this->__isset.shard_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->max_rows);
          this->__isset.max_rows = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TTableMeta::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TTableMeta");

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num_cols", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->num_cols);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("col_datum_types", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->col_datum_types.size()));
    std::vector<TDatumType::type> ::const_iterator _iter166;
    for (_iter166 = this->col_datum_types.begin(); _iter166 != this->col_datum_types.end(); ++_iter166)
    {
      xfer += oprot->writeI32((int32_t)(*_iter166));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_view", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->is_view);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_replicated", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->is_replicated);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("shard_count", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->shard_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("max_rows", ::apache::thrift::protocol::T_I64, 7);
  xfer += oprot->writeI64(this->max_rows);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTableMeta &a, TTableMeta &b) {
  using ::std::swap;
  swap(a.table_name, b.table_name);
  swap(a.num_cols, b.num_cols);
  swap(a.col_datum_types, b.col_datum_types);
  swap(a.is_view, b.is_view);
  swap(a.is_replicated, b.is_replicated);
  swap(a.shard_count, b.shard_count);
  swap(a.max_rows, b.max_rows);
  swap(a.__isset, b.__isset);
}

TTableMeta::TTableMeta(const TTableMeta& other167) {
  table_name = other167.table_name;
  num_cols = other167.num_cols;
  col_datum_types = other167.col_datum_types;
  is_view = other167.is_view;
  is_replicated = other167.is_replicated;
  shard_count = other167.shard_count;
  max_rows = other167.max_rows;
  __isset = other167.__isset;
}
TTableMeta& TTableMeta::operator=(const TTableMeta& other168) {
  table_name = other168.table_name;
  num_cols = other168.num_cols;
  col_datum_types = other168.col_datum_types;
  is_view = other168.is_view;
  is_replicated = other168.is_replicated;
  shard_count = other168.shard_count;
  max_rows = other168.max_rows;
  __isset = other168.__isset;
  return *this;
}
void TTableMeta::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TTableMeta(";
  out << "table_name=" << to_string(table_name);
  out << ", " << "num_cols=" << to_string(num_cols);
  out << ", " << "col_datum_types=" << to_string(col_datum_types);
  out << ", " << "is_view=" << to_string(is_view);
  out << ", " << "is_replicated=" << to_string(is_replicated);
  out << ", " << "shard_count=" << to_string(shard_count);
  out << ", " << "max_rows=" << to_string(max_rows);
  out << ")";
}


TTableDetails::~TTableDetails() throw() {
}


void TTableDetails::__set_row_desc(const TRowDescriptor& val) {
  this->row_desc = val;
}

void TTableDetails::__set_fragment_size(const int64_t val) {
  this->fragment_size = val;
}

void TTableDetails::__set_page_size(const int64_t val) {
  this->page_size = val;
}

void TTableDetails::__set_max_rows(const int64_t val) {
  this->max_rows = val;
}

void TTableDetails::__set_view_sql(const std::string& val) {
  this->view_sql = val;
}

void TTableDetails::__set_shard_count(const int64_t val) {
  this->shard_count = val;
}

void TTableDetails::__set_key_metainfo(const std::string& val) {
  this->key_metainfo = val;
}

void TTableDetails::__set_is_temporary(const bool val) {
  this->is_temporary = val;
}
std::ostream& operator<<(std::ostream& out, const TTableDetails& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TTableDetails::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->row_desc.clear();
            uint32_t _size169;
            ::apache::thrift::protocol::TType _etype172;
            xfer += iprot->readListBegin(_etype172, _size169);
            this->row_desc.resize(_size169);
            uint32_t _i173;
            for (_i173 = 0; _i173 < _size169; ++_i173)
            {
              xfer += this->row_desc[_i173].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.row_desc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->fragment_size);
          this->__isset.fragment_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->page_size);
          this->__isset.page_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->max_rows);
          this->__isset.max_rows = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->view_sql);
          this->__isset.view_sql = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->shard_count);
          this->__isset.shard_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key_metainfo);
          this->__isset.key_metainfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_temporary);
          this->__isset.is_temporary = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TTableDetails::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TTableDetails");

  xfer += oprot->writeFieldBegin("row_desc", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->row_desc.size()));
    std::vector<TColumnType> ::const_iterator _iter174;
    for (_iter174 = this->row_desc.begin(); _iter174 != this->row_desc.end(); ++_iter174)
    {
      xfer += (*_iter174).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fragment_size", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->fragment_size);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("page_size", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->page_size);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("max_rows", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->max_rows);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("view_sql", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->view_sql);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("shard_count", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->shard_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key_metainfo", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->key_metainfo);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_temporary", ::apache::thrift::protocol::T_BOOL, 8);
  xfer += oprot->writeBool(this->is_temporary);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTableDetails &a, TTableDetails &b) {
  using ::std::swap;
  swap(a.row_desc, b.row_desc);
  swap(a.fragment_size, b.fragment_size);
  swap(a.page_size, b.page_size);
  swap(a.max_rows, b.max_rows);
  swap(a.view_sql, b.view_sql);
  swap(a.shard_count, b.shard_count);
  swap(a.key_metainfo, b.key_metainfo);
  swap(a.is_temporary, b.is_temporary);
  swap(a.__isset, b.__isset);
}

TTableDetails::TTableDetails(const TTableDetails& other175) {
  row_desc = other175.row_desc;
  fragment_size = other175.fragment_size;
  page_size = other175.page_size;
  max_rows = other175.max_rows;
  view_sql = other175.view_sql;
  shard_count = other175.shard_count;
  key_metainfo = other175.key_metainfo;
  is_temporary = other175.is_temporary;
  __isset = other175.__isset;
}
TTableDetails& TTableDetails::operator=(const TTableDetails& other176) {
  row_desc = other176.row_desc;
  fragment_size = other176.fragment_size;
  page_size = other176.page_size;
  max_rows = other176.max_rows;
  view_sql = other176.view_sql;
  shard_count = other176.shard_count;
  key_metainfo = other176.key_metainfo;
  is_temporary = other176.is_temporary;
  __isset = other176.__isset;
  return *this;
}
void TTableDetails::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TTableDetails(";
  out << "row_desc=" << to_string(row_desc);
  out << ", " << "fragment_size=" << to_string(fragment_size);
  out << ", " << "page_size=" << to_string(page_size);
  out << ", " << "max_rows=" << to_string(max_rows);
  out << ", " << "view_sql=" << to_string(view_sql);
  out << ", " << "shard_count=" << to_string(shard_count);
  out << ", " << "key_metainfo=" << to_string(key_metainfo);
  out << ", " << "is_temporary=" << to_string(is_temporary);
  out << ")";
}


TColumnRange::~TColumnRange() throw() {
}


void TColumnRange::__set_type(const TExpressionRangeType::type val) {
  this->type = val;
}

void TColumnRange::__set_col_id(const int32_t val) {
  this->col_id = val;
}

void TColumnRange::__set_table_id(const int32_t val) {
  this->table_id = val;
}

void TColumnRange::__set_has_nulls(const bool val) {
  this->has_nulls = val;
}

void TColumnRange::__set_int_min(const int64_t val) {
  this->int_min = val;
}

void TColumnRange::__set_int_max(const int64_t val) {
  this->int_max = val;
}

void TColumnRange::__set_bucket(const int64_t val) {
  this->bucket = val;
}

void TColumnRange::__set_fp_min(const double val) {
  this->fp_min = val;
}

void TColumnRange::__set_fp_max(const double val) {
  this->fp_max = val;
}
std::ostream& operator<<(std::ostream& out, const TColumnRange& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TColumnRange::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast177;
          xfer += iprot->readI32(ecast177);
          this->type = (TExpressionRangeType::type)ecast177;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->col_id);
          this->__isset.col_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->table_id);
          this->__isset.table_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->has_nulls);
          this->__isset.has_nulls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->int_min);
          this->__isset.int_min = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->int_max);
          this->__isset.int_max = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->bucket);
          this->__isset.bucket = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->fp_min);
          this->__isset.fp_min = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->fp_max);
          this->__isset.fp_max = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TColumnRange::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TColumnRange");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("col_id", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->col_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_id", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->table_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("has_nulls", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->has_nulls);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("int_min", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->int_min);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("int_max", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->int_max);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bucket", ::apache::thrift::protocol::T_I64, 7);
  xfer += oprot->writeI64(this->bucket);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fp_min", ::apache::thrift::protocol::T_DOUBLE, 8);
  xfer += oprot->writeDouble(this->fp_min);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fp_max", ::apache::thrift::protocol::T_DOUBLE, 9);
  xfer += oprot->writeDouble(this->fp_max);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TColumnRange &a, TColumnRange &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.col_id, b.col_id);
  swap(a.table_id, b.table_id);
  swap(a.has_nulls, b.has_nulls);
  swap(a.int_min, b.int_min);
  swap(a.int_max, b.int_max);
  swap(a.bucket, b.bucket);
  swap(a.fp_min, b.fp_min);
  swap(a.fp_max, b.fp_max);
  swap(a.__isset, b.__isset);
}

TColumnRange::TColumnRange(const TColumnRange& other178) {
  type = other178.type;
  col_id = other178.col_id;
  table_id = other178.table_id;
  has_nulls = other178.has_nulls;
  int_min = other178.int_min;
  int_max = other178.int_max;
  bucket = other178.bucket;
  fp_min = other178.fp_min;
  fp_max = other178.fp_max;
  __isset = other178.__isset;
}
TColumnRange& TColumnRange::operator=(const TColumnRange& other179) {
  type = other179.type;
  col_id = other179.col_id;
  table_id = other179.table_id;
  has_nulls = other179.has_nulls;
  int_min = other179.int_min;
  int_max = other179.int_max;
  bucket = other179.bucket;
  fp_min = other179.fp_min;
  fp_max = other179.fp_max;
  __isset = other179.__isset;
  return *this;
}
void TColumnRange::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TColumnRange(";
  out << "type=" << to_string(type);
  out << ", " << "col_id=" << to_string(col_id);
  out << ", " << "table_id=" << to_string(table_id);
  out << ", " << "has_nulls=" << to_string(has_nulls);
  out << ", " << "int_min=" << to_string(int_min);
  out << ", " << "int_max=" << to_string(int_max);
  out << ", " << "bucket=" << to_string(bucket);
  out << ", " << "fp_min=" << to_string(fp_min);
  out << ", " << "fp_max=" << to_string(fp_max);
  out << ")";
}


TDictionaryGeneration::~TDictionaryGeneration() throw() {
}


void TDictionaryGeneration::__set_dict_id(const int32_t val) {
  this->dict_id = val;
}

void TDictionaryGeneration::__set_entry_count(const int64_t val) {
  this->entry_count = val;
}
std::ostream& operator<<(std::ostream& out, const TDictionaryGeneration& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TDictionaryGeneration::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->dict_id);
          this->__isset.dict_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->entry_count);
          this->__isset.entry_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TDictionaryGeneration::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDictionaryGeneration");

  xfer += oprot->writeFieldBegin("dict_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->dict_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("entry_count", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->entry_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDictionaryGeneration &a, TDictionaryGeneration &b) {
  using ::std::swap;
  swap(a.dict_id, b.dict_id);
  swap(a.entry_count, b.entry_count);
  swap(a.__isset, b.__isset);
}

TDictionaryGeneration::TDictionaryGeneration(const TDictionaryGeneration& other180) {
  dict_id = other180.dict_id;
  entry_count = other180.entry_count;
  __isset = other180.__isset;
}
TDictionaryGeneration& TDictionaryGeneration::operator=(const TDictionaryGeneration& other181) {
  dict_id = other181.dict_id;
  entry_count = other181.entry_count;
  __isset = other181.__isset;
  return *this;
}
void TDictionaryGeneration::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDictionaryGeneration(";
  out << "dict_id=" << to_string(dict_id);
  out << ", " << "entry_count=" << to_string(entry_count);
  out << ")";
}


TTableGeneration::~TTableGeneration() throw() {
}


void TTableGeneration::__set_table_id(const int32_t val) {
  this->table_id = val;
}

void TTableGeneration::__set_tuple_count(const int64_t val) {
  this->tuple_count = val;
}

void TTableGeneration::__set_start_rowid(const int64_t val) {
  this->start_rowid = val;
}
std::ostream& operator<<(std::ostream& out, const TTableGeneration& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TTableGeneration::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->table_id);
          this->__isset.table_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->tuple_count);
          this->__isset.tuple_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->start_rowid);
          this->__isset.start_rowid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TTableGeneration::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TTableGeneration");

  xfer += oprot->writeFieldBegin("table_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->table_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tuple_count", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->tuple_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("start_rowid", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->start_rowid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTableGeneration &a, TTableGeneration &b) {
  using ::std::swap;
  swap(a.table_id, b.table_id);
  swap(a.tuple_count, b.tuple_count);
  swap(a.start_rowid, b.start_rowid);
  swap(a.__isset, b.__isset);
}

TTableGeneration::TTableGeneration(const TTableGeneration& other182) {
  table_id = other182.table_id;
  tuple_count = other182.tuple_count;
  start_rowid = other182.start_rowid;
  __isset = other182.__isset;
}
TTableGeneration& TTableGeneration::operator=(const TTableGeneration& other183) {
  table_id = other183.table_id;
  tuple_count = other183.tuple_count;
  start_rowid = other183.start_rowid;
  __isset = other183.__isset;
  return *this;
}
void TTableGeneration::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TTableGeneration(";
  out << "table_id=" << to_string(table_id);
  out << ", " << "tuple_count=" << to_string(tuple_count);
  out << ", " << "start_rowid=" << to_string(start_rowid);
  out << ")";
}


TPendingQuery::~TPendingQuery() throw() {
}


void TPendingQuery::__set_id(const TQueryId val) {
  this->id = val;
}

void TPendingQuery::__set_column_ranges(const std::vector<TColumnRange> & val) {
  this->column_ranges = val;
}

void TPendingQuery::__set_dictionary_generations(const std::vector<TDictionaryGeneration> & val) {
  this->dictionary_generations = val;
}

void TPendingQuery::__set_table_generations(const std::vector<TTableGeneration> & val) {
  this->table_generations = val;
}
std::ostream& operator<<(std::ostream& out, const TPendingQuery& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TPendingQuery::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->column_ranges.clear();
            uint32_t _size184;
            ::apache::thrift::protocol::TType _etype187;
            xfer += iprot->readListBegin(_etype187, _size184);
            this->column_ranges.resize(_size184);
            uint32_t _i188;
            for (_i188 = 0; _i188 < _size184; ++_i188)
            {
              xfer += this->column_ranges[_i188].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.column_ranges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->dictionary_generations.clear();
            uint32_t _size189;
            ::apache::thrift::protocol::TType _etype192;
            xfer += iprot->readListBegin(_etype192, _size189);
            this->dictionary_generations.resize(_size189);
            uint32_t _i193;
            for (_i193 = 0; _i193 < _size189; ++_i193)
            {
              xfer += this->dictionary_generations[_i193].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.dictionary_generations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->table_generations.clear();
            uint32_t _size194;
            ::apache::thrift::protocol::TType _etype197;
            xfer += iprot->readListBegin(_etype197, _size194);
            this->table_generations.resize(_size194);
            uint32_t _i198;
            for (_i198 = 0; _i198 < _size194; ++_i198)
            {
              xfer += this->table_generations[_i198].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.table_generations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TPendingQuery::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TPendingQuery");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("column_ranges", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->column_ranges.size()));
    std::vector<TColumnRange> ::const_iterator _iter199;
    for (_iter199 = this->column_ranges.begin(); _iter199 != this->column_ranges.end(); ++_iter199)
    {
      xfer += (*_iter199).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dictionary_generations", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->dictionary_generations.size()));
    std::vector<TDictionaryGeneration> ::const_iterator _iter200;
    for (_iter200 = this->dictionary_generations.begin(); _iter200 != this->dictionary_generations.end(); ++_iter200)
    {
      xfer += (*_iter200).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_generations", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->table_generations.size()));
    std::vector<TTableGeneration> ::const_iterator _iter201;
    for (_iter201 = this->table_generations.begin(); _iter201 != this->table_generations.end(); ++_iter201)
    {
      xfer += (*_iter201).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TPendingQuery &a, TPendingQuery &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.column_ranges, b.column_ranges);
  swap(a.dictionary_generations, b.dictionary_generations);
  swap(a.table_generations, b.table_generations);
  swap(a.__isset, b.__isset);
}

TPendingQuery::TPendingQuery(const TPendingQuery& other202) {
  id = other202.id;
  column_ranges = other202.column_ranges;
  dictionary_generations = other202.dictionary_generations;
  table_generations = other202.table_generations;
  __isset = other202.__isset;
}
TPendingQuery& TPendingQuery::operator=(const TPendingQuery& other203) {
  id = other203.id;
  column_ranges = other203.column_ranges;
  dictionary_generations = other203.dictionary_generations;
  table_generations = other203.table_generations;
  __isset = other203.__isset;
  return *this;
}
void TPendingQuery::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TPendingQuery(";
  out << "id=" << to_string(id);
  out << ", " << "column_ranges=" << to_string(column_ranges);
  out << ", " << "dictionary_generations=" << to_string(dictionary_generations);
  out << ", " << "table_generations=" << to_string(table_generations);
  out << ")";
}


TVarLen::~TVarLen() throw() {
}


void TVarLen::__set_payload(const std::string& val) {
  this->payload = val;
}

void TVarLen::__set_is_null(const bool val) {
  this->is_null = val;
}
std::ostream& operator<<(std::ostream& out, const TVarLen& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TVarLen::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->payload);
          this->__isset.payload = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_null);
          this->__isset.is_null = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TVarLen::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TVarLen");

  xfer += oprot->writeFieldBegin("payload", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->payload);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_null", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->is_null);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TVarLen &a, TVarLen &b) {
  using ::std::swap;
  swap(a.payload, b.payload);
  swap(a.is_null, b.is_null);
  swap(a.__isset, b.__isset);
}

TVarLen::TVarLen(const TVarLen& other204) {
  payload = other204.payload;
  is_null = other204.is_null;
  __isset = other204.__isset;
}
TVarLen& TVarLen::operator=(const TVarLen& other205) {
  payload = other205.payload;
  is_null = other205.is_null;
  __isset = other205.__isset;
  return *this;
}
void TVarLen::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TVarLen(";
  out << "payload=" << to_string(payload);
  out << ", " << "is_null=" << to_string(is_null);
  out << ")";
}


TDataBlockPtr::~TDataBlockPtr() throw() {
}


void TDataBlockPtr::__set_fixed_len_data(const std::string& val) {
  this->fixed_len_data = val;
__isset.fixed_len_data = true;
}

void TDataBlockPtr::__set_var_len_data(const std::vector<TVarLen> & val) {
  this->var_len_data = val;
__isset.var_len_data = true;
}
std::ostream& operator<<(std::ostream& out, const TDataBlockPtr& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TDataBlockPtr::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->fixed_len_data);
          this->__isset.fixed_len_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->var_len_data.clear();
            uint32_t _size206;
            ::apache::thrift::protocol::TType _etype209;
            xfer += iprot->readListBegin(_etype209, _size206);
            this->var_len_data.resize(_size206);
            uint32_t _i210;
            for (_i210 = 0; _i210 < _size206; ++_i210)
            {
              xfer += this->var_len_data[_i210].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.var_len_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TDataBlockPtr::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDataBlockPtr");

  if (this->__isset.fixed_len_data) {
    xfer += oprot->writeFieldBegin("fixed_len_data", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeBinary(this->fixed_len_data);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.var_len_data) {
    xfer += oprot->writeFieldBegin("var_len_data", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->var_len_data.size()));
      std::vector<TVarLen> ::const_iterator _iter211;
      for (_iter211 = this->var_len_data.begin(); _iter211 != this->var_len_data.end(); ++_iter211)
      {
        xfer += (*_iter211).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDataBlockPtr &a, TDataBlockPtr &b) {
  using ::std::swap;
  swap(a.fixed_len_data, b.fixed_len_data);
  swap(a.var_len_data, b.var_len_data);
  swap(a.__isset, b.__isset);
}

TDataBlockPtr::TDataBlockPtr(const TDataBlockPtr& other212) {
  fixed_len_data = other212.fixed_len_data;
  var_len_data = other212.var_len_data;
  __isset = other212.__isset;
}
TDataBlockPtr& TDataBlockPtr::operator=(const TDataBlockPtr& other213) {
  fixed_len_data = other213.fixed_len_data;
  var_len_data = other213.var_len_data;
  __isset = other213.__isset;
  return *this;
}
void TDataBlockPtr::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDataBlockPtr(";
  out << "fixed_len_data="; (__isset.fixed_len_data ? (out << to_string(fixed_len_data)) : (out << "<null>"));
  out << ", " << "var_len_data="; (__isset.var_len_data ? (out << to_string(var_len_data)) : (out << "<null>"));
  out << ")";
}


TInsertData::~TInsertData() throw() {
}


void TInsertData::__set_db_id(const int32_t val) {
  this->db_id = val;
}

void TInsertData::__set_table_id(const int32_t val) {
  this->table_id = val;
}

void TInsertData::__set_column_ids(const std::vector<int32_t> & val) {
  this->column_ids = val;
}

void TInsertData::__set_data(const std::vector<TDataBlockPtr> & val) {
  this->data = val;
}

void TInsertData::__set_num_rows(const int64_t val) {
  this->num_rows = val;
}
std::ostream& operator<<(std::ostream& out, const TInsertData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TInsertData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->db_id);
          this->__isset.db_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->table_id);
          this->__isset.table_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->column_ids.clear();
            uint32_t _size214;
            ::apache::thrift::protocol::TType _etype217;
            xfer += iprot->readListBegin(_etype217, _size214);
            this->column_ids.resize(_size214);
            uint32_t _i218;
            for (_i218 = 0; _i218 < _size214; ++_i218)
            {
              xfer += iprot->readI32(this->column_ids[_i218]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.column_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->data.clear();
            uint32_t _size219;
            ::apache::thrift::protocol::TType _etype222;
            xfer += iprot->readListBegin(_etype222, _size219);
            this->data.resize(_size219);
            uint32_t _i223;
            for (_i223 = 0; _i223 < _size219; ++_i223)
            {
              xfer += this->data[_i223].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->num_rows);
          this->__isset.num_rows = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TInsertData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TInsertData");

  xfer += oprot->writeFieldBegin("db_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->db_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_id", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->table_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("column_ids", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->column_ids.size()));
    std::vector<int32_t> ::const_iterator _iter224;
    for (_iter224 = this->column_ids.begin(); _iter224 != this->column_ids.end(); ++_iter224)
    {
      xfer += oprot->writeI32((*_iter224));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->data.size()));
    std::vector<TDataBlockPtr> ::const_iterator _iter225;
    for (_iter225 = this->data.begin(); _iter225 != this->data.end(); ++_iter225)
    {
      xfer += (*_iter225).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num_rows", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->num_rows);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TInsertData &a, TInsertData &b) {
  using ::std::swap;
  swap(a.db_id, b.db_id);
  swap(a.table_id, b.table_id);
  swap(a.column_ids, b.column_ids);
  swap(a.data, b.data);
  swap(a.num_rows, b.num_rows);
  swap(a.__isset, b.__isset);
}

TInsertData::TInsertData(const TInsertData& other226) {
  db_id = other226.db_id;
  table_id = other226.table_id;
  column_ids = other226.column_ids;
  data = other226.data;
  num_rows = other226.num_rows;
  __isset = other226.__isset;
}
TInsertData& TInsertData::operator=(const TInsertData& other227) {
  db_id = other227.db_id;
  table_id = other227.table_id;
  column_ids = other227.column_ids;
  data = other227.data;
  num_rows = other227.num_rows;
  __isset = other227.__isset;
  return *this;
}
void TInsertData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TInsertData(";
  out << "db_id=" << to_string(db_id);
  out << ", " << "table_id=" << to_string(table_id);
  out << ", " << "column_ids=" << to_string(column_ids);
  out << ", " << "data=" << to_string(data);
  out << ", " << "num_rows=" << to_string(num_rows);
  out << ")";
}


TPendingRenderQuery::~TPendingRenderQuery() throw() {
}


void TPendingRenderQuery::__set_id(const TQueryId val) {
  this->id = val;
}
std::ostream& operator<<(std::ostream& out, const TPendingRenderQuery& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TPendingRenderQuery::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TPendingRenderQuery::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TPendingRenderQuery");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TPendingRenderQuery &a, TPendingRenderQuery &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.__isset, b.__isset);
}

TPendingRenderQuery::TPendingRenderQuery(const TPendingRenderQuery& other228) {
  id = other228.id;
  __isset = other228.__isset;
}
TPendingRenderQuery& TPendingRenderQuery::operator=(const TPendingRenderQuery& other229) {
  id = other229.id;
  __isset = other229.__isset;
  return *this;
}
void TPendingRenderQuery::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TPendingRenderQuery(";
  out << "id=" << to_string(id);
  out << ")";
}


TRenderParseResult::~TRenderParseResult() throw() {
}


void TRenderParseResult::__set_merge_type(const TMergeType::type val) {
  this->merge_type = val;
}

void TRenderParseResult::__set_node_id(const int32_t val) {
  this->node_id = val;
}

void TRenderParseResult::__set_execution_time_ms(const int64_t val) {
  this->execution_time_ms = val;
}

void TRenderParseResult::__set_render_time_ms(const int64_t val) {
  this->render_time_ms = val;
}

void TRenderParseResult::__set_total_time_ms(const int64_t val) {
  this->total_time_ms = val;
}
std::ostream& operator<<(std::ostream& out, const TRenderParseResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TRenderParseResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast230;
          xfer += iprot->readI32(ecast230);
          this->merge_type = (TMergeType::type)ecast230;
          this->__isset.merge_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->node_id);
          this->__isset.node_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->execution_time_ms);
          this->__isset.execution_time_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->render_time_ms);
          this->__isset.render_time_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->total_time_ms);
          this->__isset.total_time_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TRenderParseResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TRenderParseResult");

  xfer += oprot->writeFieldBegin("merge_type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->merge_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("node_id", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->node_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("execution_time_ms", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->execution_time_ms);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("render_time_ms", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->render_time_ms);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("total_time_ms", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->total_time_ms);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TRenderParseResult &a, TRenderParseResult &b) {
  using ::std::swap;
  swap(a.merge_type, b.merge_type);
  swap(a.node_id, b.node_id);
  swap(a.execution_time_ms, b.execution_time_ms);
  swap(a.render_time_ms, b.render_time_ms);
  swap(a.total_time_ms, b.total_time_ms);
  swap(a.__isset, b.__isset);
}

TRenderParseResult::TRenderParseResult(const TRenderParseResult& other231) {
  merge_type = other231.merge_type;
  node_id = other231.node_id;
  execution_time_ms = other231.execution_time_ms;
  render_time_ms = other231.render_time_ms;
  total_time_ms = other231.total_time_ms;
  __isset = other231.__isset;
}
TRenderParseResult& TRenderParseResult::operator=(const TRenderParseResult& other232) {
  merge_type = other232.merge_type;
  node_id = other232.node_id;
  execution_time_ms = other232.execution_time_ms;
  render_time_ms = other232.render_time_ms;
  total_time_ms = other232.total_time_ms;
  __isset = other232.__isset;
  return *this;
}
void TRenderParseResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TRenderParseResult(";
  out << "merge_type=" << to_string(merge_type);
  out << ", " << "node_id=" << to_string(node_id);
  out << ", " << "execution_time_ms=" << to_string(execution_time_ms);
  out << ", " << "render_time_ms=" << to_string(render_time_ms);
  out << ", " << "total_time_ms=" << to_string(total_time_ms);
  out << ")";
}


TRawRenderPassDataResult::~TRawRenderPassDataResult() throw() {
}


void TRawRenderPassDataResult::__set_num_channels(const int32_t val) {
  this->num_channels = val;
}

void TRawRenderPassDataResult::__set_pixels(const std::string& val) {
  this->pixels = val;
}

void TRawRenderPassDataResult::__set_row_ids_A(const std::string& val) {
  this->row_ids_A = val;
}

void TRawRenderPassDataResult::__set_row_ids_B(const std::string& val) {
  this->row_ids_B = val;
}

void TRawRenderPassDataResult::__set_table_ids(const std::string& val) {
  this->table_ids = val;
}

void TRawRenderPassDataResult::__set_accum_data(const std::string& val) {
  this->accum_data = val;
}
std::ostream& operator<<(std::ostream& out, const TRawRenderPassDataResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TRawRenderPassDataResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num_channels);
          this->__isset.num_channels = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->pixels);
          this->__isset.pixels = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->row_ids_A);
          this->__isset.row_ids_A = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->row_ids_B);
          this->__isset.row_ids_B = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->table_ids);
          this->__isset.table_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->accum_data);
          this->__isset.accum_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TRawRenderPassDataResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TRawRenderPassDataResult");

  xfer += oprot->writeFieldBegin("num_channels", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->num_channels);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pixels", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->pixels);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("row_ids_A", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->row_ids_A);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("row_ids_B", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary(this->row_ids_B);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_ids", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeBinary(this->table_ids);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("accum_data", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeBinary(this->accum_data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TRawRenderPassDataResult &a, TRawRenderPassDataResult &b) {
  using ::std::swap;
  swap(a.num_channels, b.num_channels);
  swap(a.pixels, b.pixels);
  swap(a.row_ids_A, b.row_ids_A);
  swap(a.row_ids_B, b.row_ids_B);
  swap(a.table_ids, b.table_ids);
  swap(a.accum_data, b.accum_data);
  swap(a.__isset, b.__isset);
}

TRawRenderPassDataResult::TRawRenderPassDataResult(const TRawRenderPassDataResult& other233) {
  num_channels = other233.num_channels;
  pixels = other233.pixels;
  row_ids_A = other233.row_ids_A;
  row_ids_B = other233.row_ids_B;
  table_ids = other233.table_ids;
  accum_data = other233.accum_data;
  __isset = other233.__isset;
}
TRawRenderPassDataResult& TRawRenderPassDataResult::operator=(const TRawRenderPassDataResult& other234) {
  num_channels = other234.num_channels;
  pixels = other234.pixels;
  row_ids_A = other234.row_ids_A;
  row_ids_B = other234.row_ids_B;
  table_ids = other234.table_ids;
  accum_data = other234.accum_data;
  __isset = other234.__isset;
  return *this;
}
void TRawRenderPassDataResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TRawRenderPassDataResult(";
  out << "num_channels=" << to_string(num_channels);
  out << ", " << "pixels=" << to_string(pixels);
  out << ", " << "row_ids_A=" << to_string(row_ids_A);
  out << ", " << "row_ids_B=" << to_string(row_ids_B);
  out << ", " << "table_ids=" << to_string(table_ids);
  out << ", " << "accum_data=" << to_string(accum_data);
  out << ")";
}


TRawPixelData::~TRawPixelData() throw() {
}


void TRawPixelData::__set_width(const int32_t val) {
  this->width = val;
}

void TRawPixelData::__set_height(const int32_t val) {
  this->height = val;
}

void TRawPixelData::__set_render_pass_map(const TRenderPassMap& val) {
  this->render_pass_map = val;
}
std::ostream& operator<<(std::ostream& out, const TRawPixelData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TRawPixelData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->width);
          this->__isset.width = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->height);
          this->__isset.height = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->render_pass_map.clear();
            uint32_t _size235;
            ::apache::thrift::protocol::TType _ktype236;
            ::apache::thrift::protocol::TType _vtype237;
            xfer += iprot->readMapBegin(_ktype236, _vtype237, _size235);
            uint32_t _i239;
            for (_i239 = 0; _i239 < _size235; ++_i239)
            {
              int32_t _key240;
              xfer += iprot->readI32(_key240);
              TRawRenderPassDataResult& _val241 = this->render_pass_map[_key240];
              xfer += _val241.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.render_pass_map = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TRawPixelData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TRawPixelData");

  xfer += oprot->writeFieldBegin("width", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->width);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("height", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->height);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("render_pass_map", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->render_pass_map.size()));
    std::map<int32_t, TRawRenderPassDataResult> ::const_iterator _iter242;
    for (_iter242 = this->render_pass_map.begin(); _iter242 != this->render_pass_map.end(); ++_iter242)
    {
      xfer += oprot->writeI32(_iter242->first);
      xfer += _iter242->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TRawPixelData &a, TRawPixelData &b) {
  using ::std::swap;
  swap(a.width, b.width);
  swap(a.height, b.height);
  swap(a.render_pass_map, b.render_pass_map);
  swap(a.__isset, b.__isset);
}

TRawPixelData::TRawPixelData(const TRawPixelData& other243) {
  width = other243.width;
  height = other243.height;
  render_pass_map = other243.render_pass_map;
  __isset = other243.__isset;
}
TRawPixelData& TRawPixelData::operator=(const TRawPixelData& other244) {
  width = other244.width;
  height = other244.height;
  render_pass_map = other244.render_pass_map;
  __isset = other244.__isset;
  return *this;
}
void TRawPixelData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TRawPixelData(";
  out << "width=" << to_string(width);
  out << ", " << "height=" << to_string(height);
  out << ", " << "render_pass_map=" << to_string(render_pass_map);
  out << ")";
}


TRenderDatum::~TRenderDatum() throw() {
}


void TRenderDatum::__set_type(const TDatumType::type val) {
  this->type = val;
}

void TRenderDatum::__set_cnt(const int32_t val) {
  this->cnt = val;
}

void TRenderDatum::__set_value(const std::string& val) {
  this->value = val;
}
std::ostream& operator<<(std::ostream& out, const TRenderDatum& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TRenderDatum::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast245;
          xfer += iprot->readI32(ecast245);
          this->type = (TDatumType::type)ecast245;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->cnt);
          this->__isset.cnt = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TRenderDatum::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TRenderDatum");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cnt", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->cnt);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TRenderDatum &a, TRenderDatum &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.cnt, b.cnt);
  swap(a.value, b.value);
  swap(a.__isset, b.__isset);
}

TRenderDatum::TRenderDatum(const TRenderDatum& other246) {
  type = other246.type;
  cnt = other246.cnt;
  value = other246.value;
  __isset = other246.__isset;
}
TRenderDatum& TRenderDatum::operator=(const TRenderDatum& other247) {
  type = other247.type;
  cnt = other247.cnt;
  value = other247.value;
  __isset = other247.__isset;
  return *this;
}
void TRenderDatum::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TRenderDatum(";
  out << "type=" << to_string(type);
  out << ", " << "cnt=" << to_string(cnt);
  out << ", " << "value=" << to_string(value);
  out << ")";
}


TRenderStepResult::~TRenderStepResult() throw() {
}


void TRenderStepResult::__set_merge_data(const TRenderDataAggMap& val) {
  this->merge_data = val;
}

void TRenderStepResult::__set_raw_pixel_data(const TRawPixelData& val) {
  this->raw_pixel_data = val;
}

void TRenderStepResult::__set_execution_time_ms(const int64_t val) {
  this->execution_time_ms = val;
}

void TRenderStepResult::__set_render_time_ms(const int64_t val) {
  this->render_time_ms = val;
}

void TRenderStepResult::__set_total_time_ms(const int64_t val) {
  this->total_time_ms = val;
}
std::ostream& operator<<(std::ostream& out, const TRenderStepResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TRenderStepResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->merge_data.clear();
            uint32_t _size248;
            ::apache::thrift::protocol::TType _ktype249;
            ::apache::thrift::protocol::TType _vtype250;
            xfer += iprot->readMapBegin(_ktype249, _vtype250, _size248);
            uint32_t _i252;
            for (_i252 = 0; _i252 < _size248; ++_i252)
            {
              std::string _key253;
              xfer += iprot->readString(_key253);
              std::map<std::string, std::map<std::string, std::map<std::string, std::vector<TRenderDatum> > > > & _val254 = this->merge_data[_key253];
              {
                _val254.clear();
                uint32_t _size255;
                ::apache::thrift::protocol::TType _ktype256;
                ::apache::thrift::protocol::TType _vtype257;
                xfer += iprot->readMapBegin(_ktype256, _vtype257, _size255);
                uint32_t _i259;
                for (_i259 = 0; _i259 < _size255; ++_i259)
                {
                  std::string _key260;
                  xfer += iprot->readString(_key260);
                  std::map<std::string, std::map<std::string, std::vector<TRenderDatum> > > & _val261 = _val254[_key260];
                  {
                    _val261.clear();
                    uint32_t _size262;
                    ::apache::thrift::protocol::TType _ktype263;
                    ::apache::thrift::protocol::TType _vtype264;
                    xfer += iprot->readMapBegin(_ktype263, _vtype264, _size262);
                    uint32_t _i266;
                    for (_i266 = 0; _i266 < _size262; ++_i266)
                    {
                      std::string _key267;
                      xfer += iprot->readString(_key267);
                      std::map<std::string, std::vector<TRenderDatum> > & _val268 = _val261[_key267];
                      {
                        _val268.clear();
                        uint32_t _size269;
                        ::apache::thrift::protocol::TType _ktype270;
                        ::apache::thrift::protocol::TType _vtype271;
                        xfer += iprot->readMapBegin(_ktype270, _vtype271, _size269);
                        uint32_t _i273;
                        for (_i273 = 0; _i273 < _size269; ++_i273)
                        {
                          std::string _key274;
                          xfer += iprot->readString(_key274);
                          std::vector<TRenderDatum> & _val275 = _val268[_key274];
                          {
                            _val275.clear();
                            uint32_t _size276;
                            ::apache::thrift::protocol::TType _etype279;
                            xfer += iprot->readListBegin(_etype279, _size276);
                            _val275.resize(_size276);
                            uint32_t _i280;
                            for (_i280 = 0; _i280 < _size276; ++_i280)
                            {
                              xfer += _val275[_i280].read(iprot);
                            }
                            xfer += iprot->readListEnd();
                          }
                        }
                        xfer += iprot->readMapEnd();
                      }
                    }
                    xfer += iprot->readMapEnd();
                  }
                }
                xfer += iprot->readMapEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.merge_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->raw_pixel_data.read(iprot);
          this->__isset.raw_pixel_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->execution_time_ms);
          this->__isset.execution_time_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->render_time_ms);
          this->__isset.render_time_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->total_time_ms);
          this->__isset.total_time_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TRenderStepResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TRenderStepResult");

  xfer += oprot->writeFieldBegin("merge_data", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(this->merge_data.size()));
    std::map<std::string, std::map<std::string, std::map<std::string, std::map<std::string, std::vector<TRenderDatum> > > > > ::const_iterator _iter281;
    for (_iter281 = this->merge_data.begin(); _iter281 != this->merge_data.end(); ++_iter281)
    {
      xfer += oprot->writeString(_iter281->first);
      {
        xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(_iter281->second.size()));
        std::map<std::string, std::map<std::string, std::map<std::string, std::vector<TRenderDatum> > > > ::const_iterator _iter282;
        for (_iter282 = _iter281->second.begin(); _iter282 != _iter281->second.end(); ++_iter282)
        {
          xfer += oprot->writeString(_iter282->first);
          {
            xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(_iter282->second.size()));
            std::map<std::string, std::map<std::string, std::vector<TRenderDatum> > > ::const_iterator _iter283;
            for (_iter283 = _iter282->second.begin(); _iter283 != _iter282->second.end(); ++_iter283)
            {
              xfer += oprot->writeString(_iter283->first);
              {
                xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(_iter283->second.size()));
                std::map<std::string, std::vector<TRenderDatum> > ::const_iterator _iter284;
                for (_iter284 = _iter283->second.begin(); _iter284 != _iter283->second.end(); ++_iter284)
                {
                  xfer += oprot->writeString(_iter284->first);
                  {
                    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter284->second.size()));
                    std::vector<TRenderDatum> ::const_iterator _iter285;
                    for (_iter285 = _iter284->second.begin(); _iter285 != _iter284->second.end(); ++_iter285)
                    {
                      xfer += (*_iter285).write(oprot);
                    }
                    xfer += oprot->writeListEnd();
                  }
                }
                xfer += oprot->writeMapEnd();
              }
            }
            xfer += oprot->writeMapEnd();
          }
        }
        xfer += oprot->writeMapEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("raw_pixel_data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->raw_pixel_data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("execution_time_ms", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->execution_time_ms);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("render_time_ms", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->render_time_ms);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("total_time_ms", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->total_time_ms);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TRenderStepResult &a, TRenderStepResult &b) {
  using ::std::swap;
  swap(a.merge_data, b.merge_data);
  swap(a.raw_pixel_data, b.raw_pixel_data);
  swap(a.execution_time_ms, b.execution_time_ms);
  swap(a.render_time_ms, b.render_time_ms);
  swap(a.total_time_ms, b.total_time_ms);
  swap(a.__isset, b.__isset);
}

TRenderStepResult::TRenderStepResult(const TRenderStepResult& other286) {
  merge_data = other286.merge_data;
  raw_pixel_data = other286.raw_pixel_data;
  execution_time_ms = other286.execution_time_ms;
  render_time_ms = other286.render_time_ms;
  total_time_ms = other286.total_time_ms;
  __isset = other286.__isset;
}
TRenderStepResult& TRenderStepResult::operator=(const TRenderStepResult& other287) {
  merge_data = other287.merge_data;
  raw_pixel_data = other287.raw_pixel_data;
  execution_time_ms = other287.execution_time_ms;
  render_time_ms = other287.render_time_ms;
  total_time_ms = other287.total_time_ms;
  __isset = other287.__isset;
  return *this;
}
void TRenderStepResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TRenderStepResult(";
  out << "merge_data=" << to_string(merge_data);
  out << ", " << "raw_pixel_data=" << to_string(raw_pixel_data);
  out << ", " << "execution_time_ms=" << to_string(execution_time_ms);
  out << ", " << "render_time_ms=" << to_string(render_time_ms);
  out << ", " << "total_time_ms=" << to_string(total_time_ms);
  out << ")";
}


TDatabasePermissions::~TDatabasePermissions() throw() {
}


void TDatabasePermissions::__set_create_(const bool val) {
  this->create_ = val;
}

void TDatabasePermissions::__set_delete_(const bool val) {
  this->delete_ = val;
}
std::ostream& operator<<(std::ostream& out, const TDatabasePermissions& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TDatabasePermissions::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->create_);
          this->__isset.create_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->delete_);
          this->__isset.delete_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TDatabasePermissions::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDatabasePermissions");

  xfer += oprot->writeFieldBegin("create_", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->create_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("delete_", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->delete_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDatabasePermissions &a, TDatabasePermissions &b) {
  using ::std::swap;
  swap(a.create_, b.create_);
  swap(a.delete_, b.delete_);
  swap(a.__isset, b.__isset);
}

TDatabasePermissions::TDatabasePermissions(const TDatabasePermissions& other288) {
  create_ = other288.create_;
  delete_ = other288.delete_;
  __isset = other288.__isset;
}
TDatabasePermissions& TDatabasePermissions::operator=(const TDatabasePermissions& other289) {
  create_ = other289.create_;
  delete_ = other289.delete_;
  __isset = other289.__isset;
  return *this;
}
void TDatabasePermissions::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDatabasePermissions(";
  out << "create_=" << to_string(create_);
  out << ", " << "delete_=" << to_string(delete_);
  out << ")";
}


TTablePermissions::~TTablePermissions() throw() {
}


void TTablePermissions::__set_create_(const bool val) {
  this->create_ = val;
}

void TTablePermissions::__set_drop_(const bool val) {
  this->drop_ = val;
}

void TTablePermissions::__set_select_(const bool val) {
  this->select_ = val;
}

void TTablePermissions::__set_insert_(const bool val) {
  this->insert_ = val;
}

void TTablePermissions::__set_update_(const bool val) {
  this->update_ = val;
}

void TTablePermissions::__set_delete_(const bool val) {
  this->delete_ = val;
}

void TTablePermissions::__set_truncate_(const bool val) {
  this->truncate_ = val;
}
std::ostream& operator<<(std::ostream& out, const TTablePermissions& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TTablePermissions::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->create_);
          this->__isset.create_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->drop_);
          this->__isset.drop_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->select_);
          this->__isset.select_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->insert_);
          this->__isset.insert_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->update_);
          this->__isset.update_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->delete_);
          this->__isset.delete_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->truncate_);
          this->__isset.truncate_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TTablePermissions::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TTablePermissions");

  xfer += oprot->writeFieldBegin("create_", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->create_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("drop_", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->drop_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("select_", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->select_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("insert_", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->insert_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("update_", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->update_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("delete_", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool(this->delete_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("truncate_", ::apache::thrift::protocol::T_BOOL, 7);
  xfer += oprot->writeBool(this->truncate_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTablePermissions &a, TTablePermissions &b) {
  using ::std::swap;
  swap(a.create_, b.create_);
  swap(a.drop_, b.drop_);
  swap(a.select_, b.select_);
  swap(a.insert_, b.insert_);
  swap(a.update_, b.update_);
  swap(a.delete_, b.delete_);
  swap(a.truncate_, b.truncate_);
  swap(a.__isset, b.__isset);
}

TTablePermissions::TTablePermissions(const TTablePermissions& other290) {
  create_ = other290.create_;
  drop_ = other290.drop_;
  select_ = other290.select_;
  insert_ = other290.insert_;
  update_ = other290.update_;
  delete_ = other290.delete_;
  truncate_ = other290.truncate_;
  __isset = other290.__isset;
}
TTablePermissions& TTablePermissions::operator=(const TTablePermissions& other291) {
  create_ = other291.create_;
  drop_ = other291.drop_;
  select_ = other291.select_;
  insert_ = other291.insert_;
  update_ = other291.update_;
  delete_ = other291.delete_;
  truncate_ = other291.truncate_;
  __isset = other291.__isset;
  return *this;
}
void TTablePermissions::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TTablePermissions(";
  out << "create_=" << to_string(create_);
  out << ", " << "drop_=" << to_string(drop_);
  out << ", " << "select_=" << to_string(select_);
  out << ", " << "insert_=" << to_string(insert_);
  out << ", " << "update_=" << to_string(update_);
  out << ", " << "delete_=" << to_string(delete_);
  out << ", " << "truncate_=" << to_string(truncate_);
  out << ")";
}


TDashboardPermissions::~TDashboardPermissions() throw() {
}


void TDashboardPermissions::__set_create_(const bool val) {
  this->create_ = val;
}

void TDashboardPermissions::__set_delete_(const bool val) {
  this->delete_ = val;
}

void TDashboardPermissions::__set_view_(const bool val) {
  this->view_ = val;
}

void TDashboardPermissions::__set_edit_(const bool val) {
  this->edit_ = val;
}
std::ostream& operator<<(std::ostream& out, const TDashboardPermissions& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TDashboardPermissions::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->create_);
          this->__isset.create_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->delete_);
          this->__isset.delete_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->view_);
          this->__isset.view_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->edit_);
          this->__isset.edit_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TDashboardPermissions::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDashboardPermissions");

  xfer += oprot->writeFieldBegin("create_", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->create_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("delete_", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->delete_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("view_", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->view_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("edit_", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->edit_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDashboardPermissions &a, TDashboardPermissions &b) {
  using ::std::swap;
  swap(a.create_, b.create_);
  swap(a.delete_, b.delete_);
  swap(a.view_, b.view_);
  swap(a.edit_, b.edit_);
  swap(a.__isset, b.__isset);
}

TDashboardPermissions::TDashboardPermissions(const TDashboardPermissions& other292) {
  create_ = other292.create_;
  delete_ = other292.delete_;
  view_ = other292.view_;
  edit_ = other292.edit_;
  __isset = other292.__isset;
}
TDashboardPermissions& TDashboardPermissions::operator=(const TDashboardPermissions& other293) {
  create_ = other293.create_;
  delete_ = other293.delete_;
  view_ = other293.view_;
  edit_ = other293.edit_;
  __isset = other293.__isset;
  return *this;
}
void TDashboardPermissions::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDashboardPermissions(";
  out << "create_=" << to_string(create_);
  out << ", " << "delete_=" << to_string(delete_);
  out << ", " << "view_=" << to_string(view_);
  out << ", " << "edit_=" << to_string(edit_);
  out << ")";
}


TViewPermissions::~TViewPermissions() throw() {
}


void TViewPermissions::__set_create_(const bool val) {
  this->create_ = val;
}

void TViewPermissions::__set_drop_(const bool val) {
  this->drop_ = val;
}

void TViewPermissions::__set_select_(const bool val) {
  this->select_ = val;
}

void TViewPermissions::__set_insert_(const bool val) {
  this->insert_ = val;
}

void TViewPermissions::__set_update_(const bool val) {
  this->update_ = val;
}

void TViewPermissions::__set_delete_(const bool val) {
  this->delete_ = val;
}
std::ostream& operator<<(std::ostream& out, const TViewPermissions& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TViewPermissions::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->create_);
          this->__isset.create_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->drop_);
          this->__isset.drop_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->select_);
          this->__isset.select_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->insert_);
          this->__isset.insert_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->update_);
          this->__isset.update_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->delete_);
          this->__isset.delete_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TViewPermissions::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TViewPermissions");

  xfer += oprot->writeFieldBegin("create_", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->create_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("drop_", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->drop_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("select_", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->select_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("insert_", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->insert_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("update_", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->update_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("delete_", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool(this->delete_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TViewPermissions &a, TViewPermissions &b) {
  using ::std::swap;
  swap(a.create_, b.create_);
  swap(a.drop_, b.drop_);
  swap(a.select_, b.select_);
  swap(a.insert_, b.insert_);
  swap(a.update_, b.update_);
  swap(a.delete_, b.delete_);
  swap(a.__isset, b.__isset);
}

TViewPermissions::TViewPermissions(const TViewPermissions& other294) {
  create_ = other294.create_;
  drop_ = other294.drop_;
  select_ = other294.select_;
  insert_ = other294.insert_;
  update_ = other294.update_;
  delete_ = other294.delete_;
  __isset = other294.__isset;
}
TViewPermissions& TViewPermissions::operator=(const TViewPermissions& other295) {
  create_ = other295.create_;
  drop_ = other295.drop_;
  select_ = other295.select_;
  insert_ = other295.insert_;
  update_ = other295.update_;
  delete_ = other295.delete_;
  __isset = other295.__isset;
  return *this;
}
void TViewPermissions::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TViewPermissions(";
  out << "create_=" << to_string(create_);
  out << ", " << "drop_=" << to_string(drop_);
  out << ", " << "select_=" << to_string(select_);
  out << ", " << "insert_=" << to_string(insert_);
  out << ", " << "update_=" << to_string(update_);
  out << ", " << "delete_=" << to_string(delete_);
  out << ")";
}


TDBObject::~TDBObject() throw() {
}


void TDBObject::__set_objectName(const std::string& val) {
  this->objectName = val;
}

void TDBObject::__set_objectType(const TDBObjectType::type val) {
  this->objectType = val;
}

void TDBObject::__set_privs(const std::vector<bool> & val) {
  this->privs = val;
}

void TDBObject::__set_grantee(const std::string& val) {
  this->grantee = val;
}
std::ostream& operator<<(std::ostream& out, const TDBObject& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TDBObject::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->objectName);
          this->__isset.objectName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast296;
          xfer += iprot->readI32(ecast296);
          this->objectType = (TDBObjectType::type)ecast296;
          this->__isset.objectType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->privs.clear();
            uint32_t _size297;
            ::apache::thrift::protocol::TType _etype300;
            xfer += iprot->readListBegin(_etype300, _size297);
            this->privs.resize(_size297);
            uint32_t _i301;
            for (_i301 = 0; _i301 < _size297; ++_i301)
            {
              xfer += iprot->readBool(this->privs[_i301]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.privs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->grantee);
          this->__isset.grantee = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TDBObject::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDBObject");

  xfer += oprot->writeFieldBegin("objectName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->objectName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("objectType", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->objectType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("privs", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>(this->privs.size()));
    std::vector<bool> ::const_iterator _iter302;
    for (_iter302 = this->privs.begin(); _iter302 != this->privs.end(); ++_iter302)
    {
      xfer += oprot->writeBool((*_iter302));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("grantee", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->grantee);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDBObject &a, TDBObject &b) {
  using ::std::swap;
  swap(a.objectName, b.objectName);
  swap(a.objectType, b.objectType);
  swap(a.privs, b.privs);
  swap(a.grantee, b.grantee);
  swap(a.__isset, b.__isset);
}

TDBObject::TDBObject(const TDBObject& other303) {
  objectName = other303.objectName;
  objectType = other303.objectType;
  privs = other303.privs;
  grantee = other303.grantee;
  __isset = other303.__isset;
}
TDBObject& TDBObject::operator=(const TDBObject& other304) {
  objectName = other304.objectName;
  objectType = other304.objectType;
  privs = other304.privs;
  grantee = other304.grantee;
  __isset = other304.__isset;
  return *this;
}
void TDBObject::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDBObject(";
  out << "objectName=" << to_string(objectName);
  out << ", " << "objectType=" << to_string(objectType);
  out << ", " << "privs=" << to_string(privs);
  out << ", " << "grantee=" << to_string(grantee);
  out << ")";
}


TDashboardGrantees::~TDashboardGrantees() throw() {
}


void TDashboardGrantees::__set_name(const std::string& val) {
  this->name = val;
}

void TDashboardGrantees::__set_is_user(const bool val) {
  this->is_user = val;
}

void TDashboardGrantees::__set_permissions(const TDashboardPermissions& val) {
  this->permissions = val;
}
std::ostream& operator<<(std::ostream& out, const TDashboardGrantees& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TDashboardGrantees::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_user);
          this->__isset.is_user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->permissions.read(iprot);
          this->__isset.permissions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TDashboardGrantees::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDashboardGrantees");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_user", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->is_user);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("permissions", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->permissions.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDashboardGrantees &a, TDashboardGrantees &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.is_user, b.is_user);
  swap(a.permissions, b.permissions);
  swap(a.__isset, b.__isset);
}

TDashboardGrantees::TDashboardGrantees(const TDashboardGrantees& other305) {
  name = other305.name;
  is_user = other305.is_user;
  permissions = other305.permissions;
  __isset = other305.__isset;
}
TDashboardGrantees& TDashboardGrantees::operator=(const TDashboardGrantees& other306) {
  name = other306.name;
  is_user = other306.is_user;
  permissions = other306.permissions;
  __isset = other306.__isset;
  return *this;
}
void TDashboardGrantees::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDashboardGrantees(";
  out << "name=" << to_string(name);
  out << ", " << "is_user=" << to_string(is_user);
  out << ", " << "permissions=" << to_string(permissions);
  out << ")";
}


TLicenseInfo::~TLicenseInfo() throw() {
}


void TLicenseInfo::__set_claims(const std::vector<std::string> & val) {
  this->claims = val;
}
std::ostream& operator<<(std::ostream& out, const TLicenseInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TLicenseInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->claims.clear();
            uint32_t _size307;
            ::apache::thrift::protocol::TType _etype310;
            xfer += iprot->readListBegin(_etype310, _size307);
            this->claims.resize(_size307);
            uint32_t _i311;
            for (_i311 = 0; _i311 < _size307; ++_i311)
            {
              xfer += iprot->readString(this->claims[_i311]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.claims = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TLicenseInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TLicenseInfo");

  xfer += oprot->writeFieldBegin("claims", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->claims.size()));
    std::vector<std::string> ::const_iterator _iter312;
    for (_iter312 = this->claims.begin(); _iter312 != this->claims.end(); ++_iter312)
    {
      xfer += oprot->writeString((*_iter312));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TLicenseInfo &a, TLicenseInfo &b) {
  using ::std::swap;
  swap(a.claims, b.claims);
  swap(a.__isset, b.__isset);
}

TLicenseInfo::TLicenseInfo(const TLicenseInfo& other313) {
  claims = other313.claims;
  __isset = other313.__isset;
}
TLicenseInfo& TLicenseInfo::operator=(const TLicenseInfo& other314) {
  claims = other314.claims;
  __isset = other314.__isset;
  return *this;
}
void TLicenseInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TLicenseInfo(";
  out << "claims=" << to_string(claims);
  out << ")";
}


